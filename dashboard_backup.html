<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CTI-sHARE Threat Intelligence Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
        .header { 
            background: rgba(255,255,255,0.95); 
            padding: 30px; 
            border-radius: 15px; 
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            text-align: center;
            position: relative;
        }
        
        /* Alert System Styles */
        .alert-system {
            position: absolute;
            top: 15px;
            right: 20px;
            z-index: 9999;
        }
        
        .alert-bell {
            position: relative;
            display: inline-block;
            cursor: pointer;
            padding: 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 50%;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            transition: all 0.3s ease;
        }
        
        .alert-bell:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
        
        .alert-bell svg {
            width: 24px;
            height: 24px;
            fill: white;
        }
        
        .alert-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #dc3545;
            color: white;
            border-radius: 50%;
            min-width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        .notification-panel {
            position: absolute;
            top: 60px;
            right: 0;
            width: 380px;
            max-height: 500px;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            overflow: hidden;
            transform: translateY(-10px) scale(0.95);
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            z-index: 10000;
        }
        
        .notification-panel.show {
            transform: translateY(0) scale(1);
            opacity: 1;
            visibility: visible;
        }
        
        /* ABSOLUTE PRIORITY: Notification panel above ALL body elements */
        .notification-panel {
            position: fixed !important;
            top: 80px !important;
            right: 20px !important;
            z-index: 2147483647 !important; /* Maximum possible z-index value */
            isolation: isolate !important;
            will-change: transform, opacity !important;
        }
        
        /* Backdrop with very high z-index */
        .notification-backdrop {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            background: rgba(0,0,0,0.1) !important;
            z-index: 2147483646 !important; /* Just below notification panel */
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            pointer-events: none;
        }
        
        /* Alert system container with maximum priority */
        .alert-system {
            position: absolute !important;
            top: 15px !important;
            right: 20px !important;
            z-index: 2147483645 !important;
        }
        
        /* Push notifications with absolute maximum priority */
        .push-notification {
            position: fixed !important;
            top: 20px !important;
            right: 20px !important;
            width: 350px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            transform: translateX(400px);
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 2147483647 !important; /* Same as notification panel for equal priority */
            border-left: 4px solid #667eea;
            isolation: isolate !important;
        }
        
        /* Override any potential z-index conflicts from body elements */
        body * {
            z-index: auto;
        }
        
        /* Ensure notification elements are never overridden */
        .notification-panel,
        .notification-backdrop, 
        .alert-system,
        .push-notification {
            z-index: 2147483647 !important;
        }
        
        /* Create new stacking context for notifications */
        .notification-container {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
            pointer-events: none !important;
            z-index: 2147483647 !important;
        }
        
        .notification-container * {
            pointer-events: auto !important;
        }
        
        .notification-backdrop.show {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
        }
        
        .notification-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .notification-header h3 {
            margin: 0;
            font-size: 16px;
        }
        
        .panel-controls {
            display: flex;
            gap: 10px;
        }
        
        .control-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 5px 8px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }
        
        .control-btn:hover {
            background: rgba(255,255,255,0.3);
        }
        
        .notification-list {
            max-height: 400px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #ddd transparent;
        }
        
        .notification-list::-webkit-scrollbar {
            width: 6px;
        }
        
        .notification-list::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        
        .notification-list::-webkit-scrollbar-thumb {
            background: #ddd;
            border-radius: 3px;
        }
        
        .notification-item {
            padding: 15px 20px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background 0.2s ease;
            position: relative;
        }
        
        .notification-item:hover {
            background: #f8f9fa;
        }
        
        .notification-item.unread {
            background: linear-gradient(90deg, rgba(102, 126, 234, 0.05) 0%, rgba(255,255,255,1) 100%);
            border-left: 4px solid #667eea;
        }
        
        .notification-item.critical {
            border-left: 4px solid #dc3545;
            background: linear-gradient(90deg, rgba(220, 53, 69, 0.05) 0%, rgba(255,255,255,1) 100%);
        }
        
        .notification-item.warning {
            border-left: 4px solid #ffc107;
            background: linear-gradient(90deg, rgba(255, 193, 7, 0.05) 0%, rgba(255,255,255,1) 100%);
        }
        
        .notification-item.info {
            border-left: 4px solid #17a2b8;
            background: linear-gradient(90deg, rgba(23, 162, 184, 0.05) 0%, rgba(255,255,255,1) 100%);
        }
        
        .notification-content {
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }
        
        .notification-icon {
            flex-shrink: 0;
            width: 20px;
            height: 20px;
            margin-top: 2px;
        }
        
        .notification-body {
            flex: 1;
        }
        
        .notification-title {
            font-weight: 600;
            margin-bottom: 4px;
            font-size: 14px;
            color: #333;
        }
        
        .notification-message {
            font-size: 13px;
            color: #666;
            line-height: 1.4;
            margin-bottom: 6px;
        }
        
        .notification-time {
            font-size: 11px;
            color: #999;
        }
        
        .notification-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }
        
        .notification-action {
            background: none;
            border: 1px solid #ddd;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s ease;
        }
        
        .notification-action:hover {
            background: #f8f9fa;
            border-color: #aaa;
        }
        
        .notification-action.primary {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }
        
        .notification-action.primary:hover {
            background: #5a6fd8;
        }
        
        .no-notifications {
            text-align: center;
            padding: 40px 20px;
            color: #999;
        }
        
        .push-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 350px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            transform: translateX(400px);
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 15000;
            border-left: 4px solid #667eea;
        }
        
        .push-notification.show {
            transform: translateX(0);
            opacity: 1;
        }
        
        .push-notification.critical {
            border-left-color: #dc3545;
        }
        
        .push-notification.warning {
            border-left-color: #ffc107;
        }
        
        .push-notification.info {
            border-left-color: #17a2b8;
        }
        
        .push-content {
            padding: 15px;
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }
        
        .push-icon {
            flex-shrink: 0;
            width: 24px;
            height: 24px;
        }
        
        .push-body {
            flex: 1;
        }
        
        .push-title {
            font-weight: 600;
            margin-bottom: 4px;
            color: #333;
        }
        
        .push-message {
            font-size: 13px;
            color: #666;
            line-height: 1.4;
        }
        
        .push-close {
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: #999;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .push-close:hover {
            color: #666;
        }
        
        /* Live Update Indicators */
        .live-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            background: #dc3545;
            border-radius: 50%;
            margin-left: 8px;
            animation: livePulse 2s infinite;
        }
        
        .live-indicator.inactive {
            background: #6c757d;
            animation: none;
        }
        
        @keyframes livePulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
            100% { opacity: 1; transform: scale(1); }
        }
        
        @keyframes slideInLeft {
            from {
                opacity: 0;
                transform: translateX(-30px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(30px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        .notification-live-badge {
            background: #dc3545;
            color: white;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 8px;
            font-weight: bold;
        }
        
        .live-stats {
            font-size: 11px;
            color: #999;
            margin-top: 5px;
            padding: 8px 15px;
            background: rgba(0,0,0,0.02);
            border-top: 1px solid #eee;
        }
        
        .live-toggle-active {
            background: rgba(220, 53, 69, 0.2) !important;
            color: #dc3545 !important;
        }
        
        .live-toggle-inactive {
            background: rgba(108, 117, 125, 0.2) !important;
            color: #6c757d !important;
        }
        .stats-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); 
            gap: 20px; 
            margin-bottom: 30px;
        }
        .stat-card { 
            background: rgba(255,255,255,0.95); 
            padding: 25px; 
            border-radius: 15px; 
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            text-align: center;
        }
        .stat-number { 
            font-size: 2.5em; 
            font-weight: bold; 
            color: #667eea; 
            margin-bottom: 10px;
        }
        .stat-label { font-size: 1.1em; color: #666; }
        .card { 
            background: rgba(255,255,255,0.95); 
            padding: 25px; 
            border-radius: 15px; 
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            margin-bottom: 25px; 
        }
        .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 25px; }
        .grid-3 { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; }
        .threat-item { 
            background: #f8f9fa; 
            padding: 15px; 
            margin: 10px 0; 
            border-radius: 8px;
            border-left: 4px solid #28a745;
        }
        .threat-high { border-left-color: #dc3545; }
        .threat-medium { border-left-color: #ffc107; }
        .threat-low { border-left-color: #28a745; }
        button { 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white; 
            border: none; 
            padding: 12px 24px; 
            border-radius: 8px; 
            cursor: pointer; 
            margin: 8px 4px;
            font-weight: bold;
            transition: all 0.3s;
        }
        button:hover { transform: translateY(-2px); box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
        button:disabled { opacity: 0.6; cursor: not-allowed; transform: none; }
        button.success { background: linear-gradient(135deg, #28a745 0%, #20c997 100%); }
        button.danger { background: linear-gradient(135deg, #dc3545 0%, #e83e8c 100%); }
        button.warning { background: linear-gradient(135deg, #ffc107 0%, #fd7e14 100%); color: #000; }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            background: #28a745;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #ddd;
            border-radius: 4px;
            margin: 10px 0;
            overflow: hidden;
        }
        .progress {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        .operation-status {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #667eea;
        }
        .analysis-result {
            background: #e8f4fd;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }
        textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            margin: 10px 0;
            font-family: inherit;
            resize: vertical;
        }
        textarea:focus { border-color: #667eea; outline: none; }
        input[type="text"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            margin: 10px 0;
            font-size: 16px;
        }
        input[type="text"]:focus { border-color: #667eea; outline: none; }
        .realtime-status {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: bold;
        }
        .realtime-active { background: #28a745; color: white; }
        .realtime-inactive { background: #dc3545; color: white; }
        .chart-container {
            position: relative;
            height: 400px;
            width: 100%;
            margin: 20px 0;
        }
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #eee;
        }
        .chart-controls {
            display: flex;
            gap: 10px;
        }
        .chart-controls button {
            padding: 8px 16px;
            font-size: 0.9em;
        }
        .metric-card {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-left: 4px solid #667eea;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .metric-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #667eea;
        }
        .metric-trend {
            font-size: 0.9em;
            padding: 2px 8px;
            border-radius: 12px;
            color: white;
        }
        .trend-up { background: #28a745; }
        .trend-down { background: #dc3545; }
        .trend-stable { background: #6c757d; }
        @media (max-width: 768px) {
            .grid-2 { grid-template-columns: 1fr; }
            .stats-grid { grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); }
            .chart-container { height: 300px; }
            .chart-header { flex-direction: column; align-items: flex-start; gap: 10px; }
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <!-- Alert System in Header -->
            <div class="alert-system">
                <button class="alert-bell" id="alertBell" onclick="toggleNotificationPanel()">
                    <svg viewBox="0 0 24 24">
                        <path d="M12 22c1.1 0 2-.9 2-2h-4c0 1.1.89 2 2 2zm6-6v-5c0-3.07-1.64-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.63 5.36 6 7.92 6 11v5l-2 2v1h16v-1l-2-2z"/>
                    </svg>
                    <span class="alert-badge" id="alertBadge">0</span>
                </button>
            </div>
            

            
            <h1>üõ°Ô∏è CTI-sHARE Threat Intelligence Dashboard</h1>
            <p>AI-driven Semantic Framework for Advanced Cyber Threat Analysis and Sharing</p>
            <p><span class="status-indicator"></span>System Online | <span id="realtimeStatusHeader" class="realtime-status realtime-inactive">Real-time: Inactive</span></p>
        </div>

        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-number" id="totalThreats">0</div>
                <div class="stat-label">Total Threats</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="highSeverity">0</div>
                <div class="stat-label">High Severity</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="detectionRate">0%</div>
                <div class="stat-label">Detection Rate</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="systemStatus">Active</div>
                <div class="stat-label">System Status</div>
            </div>
        </div>

        <div class="card">
            <h2>ü§ñ AI Operations Center</h2>
            <div class="grid-3">
                <div style="text-align: center;">
                    <h3>üöÄ Model Training</h3>
                    <p>Train ML models with latest threat data</p>
                    <button onclick="trainModels()" id="trainBtn">Train Models</button>
                </div>
                <div style="text-align: center;">
                    <h3>‚ö° Real-time Detection</h3>
                    <p>Monitor threats in real-time</p>
                    <button onclick="toggleRealtime()" id="realtimeBtn">Start Real-time</button>
                </div>
                <div style="text-align: center;">
                    <h3>üîç Text Analysis</h3>
                    <p>Analyze text for threat indicators</p>
                    <button onclick="showAnalyzer()" id="analyzeBtn">Analyze Text</button>
                    <button onclick="showBulkAnalyzer()" id="bulkBtn">Bulk Analysis</button>
                </div>
            </div>
            
            <div id="operationStatus" class="operation-status" style="display: none;">
                <div id="statusMessage">Ready for operations...</div>
                <div class="progress-bar">
                    <div id="progress" class="progress" style="width: 0%;"></div>
                </div>
            </div>
        </div>

        <div class="card" id="analyzerCard" style="display: none;">
            <h2>üîç Threat Analysis</h2>
            <textarea id="analyzeText" placeholder="Enter text to analyze for threats (e.g., 'Suspicious email with malware attachment detected', 'DDoS attack on network infrastructure', etc.)" rows="4"></textarea>
            <div style="margin: 10px 0;">
                <button onclick="analyzeText()" id="analyzeSubmitBtn">Analyze Threat Text</button>
                <button onclick="extractEntities()" id="entitiesBtn">Extract Entities</button>
            </div>
            <div id="analysisResult" class="analysis-result" style="display: none;"></div>
            <div id="entitiesResult" class="analysis-result" style="display: none;"></div>
        </div>

        <div class="card">
            <h2>üåê Threat Intelligence Sharing</h2>
            <div class="grid-3">
                <div style="text-align: center;">
                    <h3>üì§ Upload Intelligence</h3>
                    <p>Upload threat data from files</p>
                    <input type="file" id="fileUpload" accept=".json,.csv,.txt" style="margin: 10px 0; padding: 8px;">
                    <button onclick="uploadIntelligence()" id="uploadBtn">Upload File</button>
                </div>
                <div style="text-align: center;">
                    <h3>üì• Import from Sources</h3>
                    <p>Import from MISP, STIX, TAXII</p>
                    <select id="importSource" style="margin: 10px 0; padding: 8px; border-radius: 4px;">
                        <option value="manual">Manual</option>
                        <option value="misp">MISP</option>
                        <option value="stix">STIX</option>
                        <option value="taxii">TAXII</option>
                    </select>
                    <button onclick="showImportDialog()" id="importBtn">Import Data</button>
                </div>
                <div style="text-align: center;">
                    <h3>üì§ Export & Share</h3>
                    <p>Export and share threat data</p>
                    <select id="exportFormat" style="margin: 10px 0; padding: 8px; border-radius: 4px;">
                        <option value="json">JSON</option>
                        <option value="csv">CSV</option>
                        <option value="stix">STIX</option>
                    </select>
                    <button onclick="exportIntelligence()" id="exportBtn">Export Data</button>
                </div>
            </div>
            
            <div id="intelligenceStatus" class="operation-status" style="display: none;">
                <div id="intelligenceMessage">Processing...</div>
                <div class="progress-bar">
                    <div id="intelligenceProgress" class="progress" style="width: 0%;"></div>
                </div>
            </div>
        </div>

        <div class="card" id="importDialog" style="display: none;">
            <h2>üì• Import Threat Intelligence</h2>
            <div style="margin-bottom: 15px;">
                <label><strong>Import Source:</strong></label>
                <select id="importSourceSelect" style="width: 100%; padding: 10px; margin: 5px 0;">
                    <option value="manual">Manual Entry</option>
                    <option value="misp">MISP Format</option>
                    <option value="stix">STIX Format</option>
                    <option value="taxii">TAXII Feed</option>
                </select>
            </div>
            <div style="margin-bottom: 15px;">
                <label><strong>Data to Import:</strong></label>
                <textarea id="importData" placeholder="Paste JSON data or enter threat descriptions (one per line)..." rows="6" style="width: 100%; padding: 10px; margin: 5px 0;"></textarea>
            </div>
            <div>
                <button onclick="importIntelligence()" id="importSubmitBtn">Import Data</button>
                <button onclick="hideImportDialog()" style="background: #6c757d;">Cancel</button>
            </div>
            <div id="importResult" class="analysis-result" style="display: none;"></div>
        </div>

        <div class="card" id="bulkAnalyzer" style="display: none;">
            <h2>üîç Bulk Semantic Analysis</h2>
            <textarea id="bulkAnalyzeText" placeholder="Enter multiple threat texts (one per line) for bulk analysis..." rows="6" style="width: 100%; padding: 10px; margin: 10px 0;"></textarea>
            <button onclick="analyzeBulk()" id="bulkAnalyzeBtn">Analyze All Texts</button>
            <div id="bulkAnalysisResult" class="analysis-result" style="display: none;"></div>
        </div>

        <div class="grid-2">
            <div class="card">
                <h2>üìä Recent Threat Activity</h2>
                <div id="recentThreats">
                    <div class="threat-item">
                        <strong>Loading threat data...</strong>
                    </div>
                </div>
                <button onclick="loadRecentThreats()">Refresh Data</button>
            </div>

            <div class="card">
                <div class="chart-header">
                    <h2>üìà Threat Categories</h2>
                    <div class="chart-controls">
                        <button onclick="loadCategories()">Update Chart</button>
                        <button onclick="exportChart('categories')">Export</button>
                    </div>
                </div>
                <div class="chart-container">
                    <canvas id="categoriesChart"></canvas>
                </div>
            </div>
        </div>

        <!-- Active Severity Distribution with Real-time Updates -->
        <div class="card">
            <div class="chart-header">
                <h2>‚ö†Ô∏è Active Severity Distribution</h2>
                <div class="chart-controls">
                    <button onclick="toggleSeverityRealtime()" id="severityRealtimeBtn">Start Real-time</button>
                    <button onclick="resetSeverityChart()">Reset</button>
                    <button onclick="exportChart('severity')">Export</button>
                </div>
            </div>
            
            <!-- Real-time Metrics -->
            <div class="grid-3" style="margin-bottom: 20px;">
                <div class="metric-card">
                    <div>
                        <div class="stat-label">Critical Rate</div>
                        <div class="metric-value" id="criticalRate">0%</div>
                    </div>
                    <div class="metric-trend trend-up" id="criticalTrend">+2.3%</div>
                </div>
                <div class="metric-card">
                    <div>
                        <div class="stat-label">Threat Velocity</div>
                        <div class="metric-value" id="threatVelocity">0/min</div>
                    </div>
                    <div class="metric-trend trend-stable" id="velocityTrend">stable</div>
                </div>
                <div class="metric-card">
                    <div>
                        <div class="stat-label">Detection Accuracy</div>
                        <div class="metric-value" id="detectionAccuracy">0%</div>
                    </div>
                    <div class="metric-trend trend-up" id="accuracyTrend">+0.5%</div>
                </div>
            </div>
            
            <div class="grid-2">
                <div>
                    <h3>Severity Distribution</h3>
                    <div class="chart-container" style="height: 300px;">
                        <canvas id="severityChart"></canvas>
                    </div>
                </div>
                <div>
                    <h3>24-Hour Trend</h3>
                    <div class="chart-container" style="height: 300px;">
                        <canvas id="severityTimeSeriesChart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- Enhanced Real-time Statistics Dashboard -->
        <div class="card">
            <div class="chart-header">
                <h2>‚ö° Real-time Statistics & System Performance</h2>
                <div class="chart-controls">
                    <button onclick="toggleAdvancedRealtime()" id="advancedRealtimeBtn">Start Monitoring</button>
                    <button onclick="refreshAdvancedStats()">Refresh</button>
                    <button onclick="exportChart('realtime')">Export</button>
                </div>
            </div>
            
            <!-- System Performance Metrics -->
            <div class="grid-3" style="margin-bottom: 20px;">
                <div class="metric-card">
                    <div>
                        <div class="stat-label">Active Incidents</div>
                        <div class="metric-value" id="activeIncidents">0</div>
                    </div>
                    <div class="metric-trend trend-down" id="incidentsTrend">-15%</div>
                </div>
                <div class="metric-card">
                    <div>
                        <div class="stat-label">Blocked Attacks</div>
                        <div class="metric-value" id="blockedAttacks">0</div>
                    </div>
                    <div class="metric-trend trend-up" id="blockedTrend">+28%</div>
                </div>
                <div class="metric-card">
                    <div>
                        <div class="stat-label">System CPU</div>
                        <div class="metric-value" id="systemCPU">0%</div>
                    </div>
                    <div class="metric-trend trend-stable" id="cpuTrend">normal</div>
                </div>
            </div>
        </div>

        <!-- Active System Health Monitor -->
        <div class="card">
            <div class="chart-header">
                <h2>üìä Active System Health Monitor</h2>
                <div class="chart-controls">
                    <button onclick="startSystemHealthLiveMode()" id="systemHealthLiveBtn">Start Health Monitor</button>
                    <button onclick="refreshSystemHealth()">Refresh</button>
                    <button onclick="exportChart('system_health')">Export</button>
                </div>
            </div>
            
            <!-- Real-time System Metrics -->
            <div class="grid-3" style="margin-bottom: 20px;">
                <div class="metric-card">
                    <div>
                        <div class="stat-label">CPU Usage</div>
                        <div class="metric-value" id="cpuUsageLive">0%</div>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="cpuProgress" style="width: 0%; background: linear-gradient(90deg, #28a745, #ffc107, #dc3545);"></div>
                    </div>
                </div>
                <div class="metric-card">
                    <div>
                        <div class="stat-label">Memory Usage</div>
                        <div class="metric-value" id="memoryUsageLive">0%</div>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="memoryProgressLive" style="width: 0%; background: linear-gradient(90deg, #17a2b8, #ffc107, #dc3545);"></div>
                    </div>
                </div>
                <div class="metric-card">
                    <div>
                        <div class="stat-label">Disk Usage</div>
                        <div class="metric-value" id="diskUsage">0%</div>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="diskProgress" style="width: 0%; background: linear-gradient(90deg, #6f42c1, #ffc107, #dc3545);"></div>
                    </div>
                </div>
            </div>
            
            <!-- Network and Connection Metrics -->
            <div class="grid-3" style="margin-top: 20px;">
                <div class="metric-card">
                    <div>
                        <div class="stat-label">Network Throughput</div>
                        <div class="metric-value" id="networkThroughputLive">0 MB/s</div>
                    </div>
                    <div class="metric-trend trend-up" id="networkTrendLive">optimal</div>
                </div>
                <div class="metric-card">
                    <div>
                        <div class="stat-label">Active Connections</div>
                        <div class="metric-value" id="activeConnectionsLive">0</div>
                    </div>
                    <div class="metric-trend trend-stable" id="connectionsTrendLive">stable</div>
                </div>
                <div class="metric-card">
                    <div>
                        <div class="stat-label">System Uptime</div>
                        <div class="metric-value" id="systemUptime">0 days</div>
                    </div>
                    <div class="metric-trend trend-up" id="uptimeTrend">excellent</div>
                </div>
            </div>
        </div>

        <!-- Active Threat Intelligence Feeds -->
        <div class="card">
            <div class="chart-header">
                <h2>üéØ Active Threat Intelligence Feeds</h2>
                <div class="chart-controls">
                    <button onclick="startThreatFeedsLiveMode()" id="threatFeedsLiveBtn">Start Feed Monitor</button>
                    <button onclick="refreshThreatFeeds()">Refresh Feeds</button>
                    <button onclick="exportChart('threat_feeds')">Export</button>
                </div>
            </div>
            
            <!-- Live Feed Status Metrics -->
            <div class="grid-3" style="margin-bottom: 20px;">
                <div class="metric-card">
                    <div>
                        <div class="stat-label">Active IOC Feeds</div>
                        <div class="metric-value" id="iocFeedsLive">0</div>
                    </div>
                    <div class="metric-trend trend-up" id="iocTrendLive">+5 new</div>
                </div>
                <div class="metric-card">
                    <div>
                        <div class="stat-label">Feed Health Score</div>
                        <div class="metric-value" id="feedHealthLive">0%</div>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="feedHealthProgress" style="width: 0%; background: linear-gradient(90deg, #dc3545, #ffc107, #28a745);"></div>
                    </div>
                </div>
                <div class="metric-card">
                    <div>
                        <div class="stat-label">Data Freshness</div>
                        <div class="metric-value" id="dataFreshnessLive">0 min</div>
                    </div>
                    <div class="metric-trend trend-up" id="freshnessTrendLive">up to date</div>
                </div>
            </div>
            
            <!-- Feed Details Table -->
            <div style="margin-top: 20px;">
                <h3>Active Feed Sources</h3>
                <div id="feedSourcesTable" style="max-height: 200px; overflow-y: auto;">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr style="background: #f8f9fa; border-bottom: 2px solid #dee2e6;">
                                <th style="padding: 10px; text-align: left;">Feed Name</th>
                                <th style="padding: 10px; text-align: center;">Status</th>
                                <th style="padding: 10px; text-align: center;">IOCs</th>
                                <th style="padding: 10px; text-align: center;">Last Update</th>
                                <th style="padding: 10px; text-align: center;">Health</th>
                            </tr>
                        </thead>
                        <tbody id="feedTableBody">
                            <!-- Dynamic feed data will be inserted here -->
                        </tbody>
                    </table>
                </div>
            </div>
            
            <!-- Feed Performance Metrics -->
            <div class="grid-3" style="margin-top: 20px;">
                <div class="metric-card">
                    <div>
                        <div class="stat-label">Total IOCs Processed</div>
                        <div class="metric-value" id="totalIOCs">0</div>
                    </div>
                    <div class="metric-trend trend-up" id="iocProcessedTrend">+1,250 today</div>
                </div>
                <div class="metric-card">
                    <div>
                        <div class="stat-label">Feed Update Rate</div>
                        <div class="metric-value" id="feedUpdateRate">0/min</div>
                    </div>
                    <div class="metric-trend trend-stable" id="updateRateTrend">consistent</div>
                </div>
                <div class="metric-card">
                    <div>
                        <div class="stat-label">Threat Correlation Rate</div>
                        <div class="metric-value" id="correlationRate">0%</div>
                    </div>
                    <div class="metric-trend trend-up" id="correlationTrend">improving</div>
                </div>
            </div>
        </div>

        <div class="card">
            <h2>‚ûï Submit New Threat</h2>
            <input type="text" id="threatText" placeholder="Enter threat description...">
            <button onclick="submitThreat()">Submit Threat</button>
        </div>

        <div class="card">
            <h2>ÔøΩ Live Information Dashboard</h2>
            <div id="liveInfoDashboard" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px; padding: 15px; background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%); border-radius: 10px;">
                <div style="text-align: center; padding: 10px; background: rgba(255,255,255,0.8); border-radius: 8px;">
                    <div style="font-size: 24px; font-weight: bold; color: #ff6b6b;" id="liveAttackVectors">0</div>
                    <div style="font-size: 12px; color: #666;">Attack Vectors Updates</div>
                </div>
                <div style="text-align: center; padding: 10px; background: rgba(255,255,255,0.8); border-radius: 8px;">
                    <div style="font-size: 24px; font-weight: bold; color: #17a2b8;" id="liveGeographic">0</div>
                    <div style="font-size: 12px; color: #666;">Geographic Updates</div>
                </div>
                <div style="text-align: center; padding: 10px; background: rgba(255,255,255,0.8); border-radius: 8px;">
                    <div style="font-size: 24px; font-weight: bold; color: #6c757d;" id="liveHourlyActivity">0</div>
                    <div style="font-size: 12px; color: #666;">Hourly Activity Updates</div>
                </div>
            </div>
            <div style="text-align: center; padding: 10px; background: rgba(0,0,0,0.05); border-radius: 8px; margin-bottom: 15px;">
                <span style="font-weight: bold; color: #333;">Live Charts Status: </span>
                <span id="liveChartsStatus" style="color: #dc3545; font-weight: bold;">üî¥ ACTIVE</span>
                <span style="margin-left: 20px; font-size: 12px; color: #666;">Updates every 3-7 seconds</span>
            </div>
        </div>

        <div class="card">
            <h2>ÔøΩüîî Alert System Testing</h2>
            <p style="margin-bottom: 15px; color: #666;">Test the notification system with different alert types:</p>
            <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                <button onclick="triggerCriticalAlert()" style="background: linear-gradient(135deg, #dc3545 0%, #c82333 100%); color: white; border: none; padding: 10px 15px; border-radius: 8px; cursor: pointer; font-size: 14px;">
                    üö® Critical Alert
                </button>
                <button onclick="triggerWarningAlert()" style="background: linear-gradient(135deg, #ffc107 0%, #e0a800 100%); color: #333; border: none; padding: 10px 15px; border-radius: 8px; cursor: pointer; font-size: 14px;">
                    ‚ö†Ô∏è Warning Alert
                </button>
                <button onclick="triggerInfoAlert()" style="background: linear-gradient(135deg, #17a2b8 0%, #138496 100%); color: white; border: none; padding: 10px 15px; border-radius: 8px; cursor: pointer; font-size: 14px;">
                    ‚ÑπÔ∏è Info Alert
                </button>
                <button onclick="generateRealtimeThreatAlert()" style="background: linear-gradient(135deg, #6f42c1 0%, #5a32a3 100%); color: white; border: none; padding: 10px 15px; border-radius: 8px; cursor: pointer; font-size: 14px;">
                    üì° Live Alert
                </button>
                <button onclick="toggleLiveUpdates()" style="background: linear-gradient(135deg, #28a745 0%, #20c997 100%); color: white; border: none; padding: 10px 15px; border-radius: 8px; cursor: pointer; font-size: 14px;">
                    üîÑ Toggle Notifications
                </button>
                <button onclick="toggleLiveCharts()" style="background: linear-gradient(135deg, #6f42c1 0%, #5a32a3 100%); color: white; border: none; padding: 10px 15px; border-radius: 8px; cursor: pointer; font-size: 14px;">
                    üìä Toggle Charts Live
                </button>
            </div>
            <p style="margin-top: 10px; font-size: 12px; color: #999;">
                ‚Ä¢ Critical alerts trigger push notifications<br>
                ‚Ä¢ Click the bell icon (üîî) in the header to view all alerts<br>
                ‚Ä¢ üì° <strong>Live Updates:</strong> Real-time alerts generated every 8-60 seconds<br>
                ‚Ä¢ üîÑ <strong>Toggle Notifications:</strong> Start/stop live notification monitoring<br>
                ‚Ä¢ üìä <strong>Toggle Charts Live:</strong> Start/stop live chart data updates<br>
                ‚Ä¢ Live information overlays appear on all active charts<br>
                ‚Ä¢ Live stats are displayed at the bottom of notification panel
            </p>
        </div>
        
        <!-- Active Incidents and Blocked Attacks Section -->
        <div class="card" style="margin-top: 20px;">
            <h2>üîç Security Operations Center</h2>
            <div class="grid-2" style="margin-top: 20px;">
                <!-- Active Incidents -->
                <div>
                    <div class="chart-header">
                        <h3>üö® Active Incidents</h3>
                        <div class="chart-controls">
                            <button class="live-btn" id="incidentsLiveBtn" onclick="toggleIncidentsLiveMode()" 
                                    style="background: linear-gradient(135deg, #28a745 0%, #20c997 100%);">
                                üî¥ Start Live Mode
                            </button>
                        </div>
                    </div>
                    <div id="activeIncidentsContainer" style="background: white; border-radius: 10px; padding: 15px; max-height: 400px; overflow-y: auto; box-shadow: 0 4px 20px rgba(0,0,0,0.1);">
                        <div id="activeIncidentsList">
                            <!-- Dynamic incidents will be populated here -->
                        </div>
                    </div>
                    <div style="text-align: center; margin-top: 10px; font-size: 12px; color: #666;">
                        Total Active: <span id="activeIncidentsCount" style="font-weight: bold; color: #dc3545;">0</span>
                    </div>
                </div>
                
                <!-- Blocked Attacks -->
                <div>
                    <div class="chart-header">
                        <h3>üõ°Ô∏è Blocked Attacks</h3>
                        <div class="chart-controls">
                            <button class="live-btn" id="blockedAttacksLiveBtn" onclick="toggleBlockedAttacksLiveMode()" 
                                    style="background: linear-gradient(135deg, #28a745 0%, #20c997 100%);">
                                üî¥ Start Live Mode
                            </button>
                        </div>
                    </div>
                    <div id="blockedAttacksContainer" style="background: white; border-radius: 10px; padding: 15px; max-height: 400px; overflow-y: auto; box-shadow: 0 4px 20px rgba(0,0,0,0.1);">
                        <div id="blockedAttacksList">
                            <!-- Dynamic blocked attacks will be populated here -->
                        </div>
                    </div>
                    <div style="text-align: center; margin-top: 10px; font-size: 12px; color: #666;">
                        Blocked Today: <span id="blockedAttacksCount" style="font-weight: bold; color: #28a745;">0</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Register Chart.js plugins
        Chart.register(ChartDataLabels);
        
        // Dashboard JavaScript functionality
        let refreshInterval;
        let isRealtimeActive = false;
        
        // Chart instances
        let categoriesChart, severityChart, severityTimeSeriesChart, attackVectorsChart, geoDistributionChart, hourlyActivityChart;
        // Charts removed: feedStatusChart, iocTypesChart
        let severityRealtimeInterval, advancedRealtimeInterval, systemHealthInterval, threatFeedsInterval;
        let isSeverityRealtimeActive = false;
        
        // Live Information System
        let liveChartsInterval = null;
        let isLiveChartsActive = true;
        let chartLiveStats = {
            attackVectorsUpdates: 0,
            geographicUpdates: 0,
            hourlyActivityUpdates: 0
        };
        let isAdvancedRealtimeActive = false;
        let isSystemHealthLive = false;
        let isThreatFeedsLive = false;

        // Initialize all charts when page loads
        document.addEventListener('DOMContentLoaded', function() {
            initializeCharts();
            loadInitialData();
        });

        function initializeCharts() {
            // Categories Chart (Doughnut)
            const categoriesCtx = document.getElementById('categoriesChart').getContext('2d');
            categoriesChart = new Chart(categoriesCtx, {
                type: 'doughnut',
                data: {
                    labels: [],
                    datasets: [{
                        data: [],
                        backgroundColor: ['#667eea', '#764ba2', '#f093fb', '#f5576c', '#4facfe'],
                        borderWidth: 2,
                        borderColor: '#fff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { 
                            position: 'bottom',
                            labels: {
                                usePointStyle: true,
                                padding: 20,
                                font: {
                                    size: 12
                                }
                            }
                        },
                        title: { 
                            display: true, 
                            text: 'Threat Categories Distribution',
                            font: {
                                size: 16,
                                weight: 'bold'
                            },
                            padding: 20
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const dataset = context.dataset;
                                    const total = dataset.data.reduce((a, b) => a + b, 0);
                                    const currentValue = dataset.data[context.dataIndex];
                                    const percentage = total > 0 ? ((currentValue / total) * 100).toFixed(1) : 0;
                                    return `${context.label}: ${currentValue} (${percentage}%)`;
                                }
                            }
                        },
                        datalabels: {
                            display: true,
                            color: 'white',
                            font: {
                                weight: 'bold',
                                size: 14
                            },
                            formatter: function(value, context) {
                                const dataset = context.dataset;
                                const total = dataset.data.reduce((a, b) => a + b, 0);
                                const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                                // Only show label if percentage is significant (>3%)
                                if (percentage > 3) {
                                    return `${percentage}%`;
                                }
                                return '';
                            },
                            anchor: 'center',
                            align: 'center',
                            textShadowColor: 'rgba(0, 0, 0, 0.7)',
                            textShadowBlur: 2
                        }
                    }
                },
                plugins: [ChartDataLabels]
            });

            // Severity Distribution Chart (Polar Area)
            const severityCtx = document.getElementById('severityChart').getContext('2d');
            severityChart = new Chart(severityCtx, {
                type: 'polarArea',
                data: {
                    labels: ['Critical', 'High', 'Medium', 'Low', 'Info'],
                    datasets: [{
                        data: [0, 0, 0, 0, 0],
                        backgroundColor: ['#dc3545', '#fd7e14', '#ffc107', '#28a745', '#17a2b8'],
                        borderWidth: 2,
                        borderColor: '#fff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'bottom' }
                    },
                    scales: {
                        r: {
                            beginAtZero: true
                        }
                    }
                }
            });

            // Severity Time Series Chart (Line)
            const severityTimeSeriesCtx = document.getElementById('severityTimeSeriesChart').getContext('2d');
            severityTimeSeriesChart = new Chart(severityTimeSeriesCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'Critical',
                            data: [],
                            borderColor: '#dc3545',
                            backgroundColor: 'rgba(220, 53, 69, 0.1)',
                            tension: 0.4
                        },
                        {
                            label: 'High',
                            data: [],
                            borderColor: '#fd7e14',
                            backgroundColor: 'rgba(253, 126, 20, 0.1)',
                            tension: 0.4
                        },
                        {
                            label: 'Medium',
                            data: [],
                            borderColor: '#ffc107',
                            backgroundColor: 'rgba(255, 193, 7, 0.1)',
                            tension: 0.4
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'top' }
                    },
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    },
                    animation: {
                        duration: 750
                    }
                }
            });


        }

        function loadInitialData() {
            loadCategories();
            loadSeverityData();
            loadAdvancedStats();
            
            // Start auto-refresh for dashboard stats
            startAutoRefresh();
        }

        function showOperationStatus(message, progress = 0) {
            const statusDiv = document.getElementById('operationStatus');
            const statusMessage = document.getElementById('statusMessage');
            const progressBar = document.getElementById('progress');
            
            statusMessage.textContent = message;
            progressBar.style.width = progress + '%';
            statusDiv.style.display = 'block';
            
            if (progress >= 100) {
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 3000);
            }
        }

        function trainModels() {
            const trainBtn = document.getElementById('trainBtn');
            trainBtn.disabled = true;
            trainBtn.textContent = 'Training...';
            
            showOperationStatus('Starting model training...', 10);
            
            fetch('/api/dashboard/train', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'}
            })
            .then(response => response.json())
            .then(data => {
                showOperationStatus('Training completed!', 100);
                
                if (data.status === 'success') {
                    trainBtn.className = 'success';
                    trainBtn.textContent = '‚úÖ Training Complete';
                    alert(`Training successful!\\nAccuracy: ${(data.metrics?.train_accuracy * 100 || 0).toFixed(1)}%`);
                } else {
                    trainBtn.className = 'danger';
                    trainBtn.textContent = '‚ùå Training Failed';
                    alert('Training failed: ' + (data.message || 'Unknown error'));
                }
            })
            .catch(error => {
                console.error('Training error:', error);
                showOperationStatus('Training failed!', 100);
                trainBtn.className = 'danger';
                trainBtn.textContent = '‚ùå Training Failed';
            })
            .finally(() => {
                setTimeout(() => {
                    trainBtn.disabled = false;
                    trainBtn.className = '';
                    trainBtn.textContent = 'üöÄ Train Models';
                }, 3000);
            });
        }

        function toggleRealtime() {
            const realtimeBtn = document.getElementById('realtimeBtn');
            const endpoint = isRealtimeActive ? '/api/dashboard/realtime/stop' : '/api/dashboard/realtime/start';
            
            realtimeBtn.disabled = true;
            
            showOperationStatus(isRealtimeActive ? 'Stopping real-time detection...' : 'Starting real-time detection...', 50);
            
            fetch(endpoint, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'}
            })
            .then(response => response.json())
            .then(data => {
                showOperationStatus(data.message, 100);
                
                if (data.status === 'success') {
                    isRealtimeActive = data.is_running;
                    updateRealtimeUI();
                } else {
                    alert(data.message || 'Operation failed');
                }
            })
            .catch(error => {
                console.error('Real-time operation error:', error);
                showOperationStatus('Operation failed!', 100);
            })
            .finally(() => {
                realtimeBtn.disabled = false;
            });
        }

        function updateRealtimeUI() {
            const realtimeBtn = document.getElementById('realtimeBtn');
            const headerStatus = document.getElementById('realtimeStatusHeader');
            
            if (isRealtimeActive) {
                realtimeBtn.textContent = '‚èπÔ∏è Stop Real-time';
                realtimeBtn.className = 'danger';
                headerStatus.textContent = 'Real-time: Active';
                headerStatus.className = 'realtime-status realtime-active';
            } else {
                realtimeBtn.textContent = '‚ñ∂Ô∏è Start Real-time';
                realtimeBtn.className = 'success';
                headerStatus.textContent = 'Real-time: Inactive';
                headerStatus.className = 'realtime-status realtime-inactive';
            }
        }

        function showAnalyzer() {
            const analyzerCard = document.getElementById('analyzerCard');
            analyzerCard.style.display = analyzerCard.style.display === 'none' ? 'block' : 'none';
            
            const analyzeBtn = document.getElementById('analyzeBtn');
            analyzeBtn.textContent = analyzerCard.style.display === 'none' ? 'üîç Analyze Text' : '‚ùå Close Analyzer';
        }

        function showBulkAnalyzer() {
            const bulkCard = document.getElementById('bulkAnalyzer');
            bulkCard.style.display = bulkCard.style.display === 'none' ? 'block' : 'none';
            
            const bulkBtn = document.getElementById('bulkBtn');
            bulkBtn.textContent = bulkCard.style.display === 'none' ? 'üìä Bulk Analysis' : '‚ùå Close Bulk';
        }

        function analyzeText() {
            const text = document.getElementById('analyzeText').value;
            const submitBtn = document.getElementById('analyzeSubmitBtn');
            const resultDiv = document.getElementById('analysisResult');
            
            if (!text.trim()) {
                alert('Please enter text to analyze');
                return;
            }
            
            submitBtn.disabled = true;
            submitBtn.textContent = 'Analyzing...';
            
            fetch('/api/dashboard/analyze', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({text: text})
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    const analysis = data.analysis;
                    const topCategory = analysis.top_category;
                    const severity = analysis.severity;
                    
                    resultDiv.innerHTML = `
                        <h3>üìä Analysis Results</h3>
                        <p><strong>Top Category:</strong> ${topCategory[0]} (${(topCategory[1] * 100).toFixed(1)}% confidence)</p>
                        <p><strong>Severity:</strong> ${severity.severity} (${(severity.confidence * 100).toFixed(1)}% confidence)</p>
                        <p><strong>Categories Found:</strong></p>
                        <ul>${Object.entries(analysis.categories).map(([cat, score]) => 
                            `<li>${cat}: ${(score * 100).toFixed(1)}%</li>`).join('')}</ul>
                        <p><strong>Timestamp:</strong> ${analysis.timestamp}</p>
                    `;
                    resultDiv.style.display = 'block';
                    
                    // Refresh recent threats to show the new analysis
                    loadRecentThreats();
                } else {
                    resultDiv.innerHTML = `<p style="color: #dc3545;">Analysis failed: ${data.message}</p>`;
                    resultDiv.style.display = 'block';
                }
            })
            .catch(error => {
                console.error('Analysis error:', error);
                resultDiv.innerHTML = '<p style="color: #dc3545;">Analysis failed due to network error</p>';
                resultDiv.style.display = 'block';
            })
            .finally(() => {
                submitBtn.disabled = false;
                submitBtn.textContent = 'Analyze Threat Text';
            });
        }

        function updateRealtimeStats() {
            fetch('/api/dashboard/realtime/status')
                .then(response => response.json())
                .then(data => {
                    const statusSpan = document.getElementById('realtimeStatus');
                    const processedSpan = document.getElementById('threatsProcessed');
                    const rateSpan = document.getElementById('realtimeDetectionRate');
                    
                    statusSpan.textContent = data.is_running ? 'Active' : 'Inactive';
                    statusSpan.style.color = data.is_running ? '#28a745' : '#dc3545';
                    
                    const stats = data.statistics || {};
                    processedSpan.textContent = stats.total_processed || 0;
                    rateSpan.textContent = ((stats.detection_rate || 0) * 100).toFixed(1) + '%';
                    
                    isRealtimeActive = data.is_running;
                    updateRealtimeUI();
                })
                .catch(error => {
                    console.error('Error loading real-time stats:', error);
                });
        }

        function loadDashboardStats() {
            fetch('/api/dashboard/stats')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('totalThreats').textContent = data.total_threats || 0;
                    document.getElementById('highSeverity').textContent = data.critical_threats || 0;
                    document.getElementById('detectionRate').textContent = (data.detection_rate || 0) + '%';
                    document.getElementById('systemStatus').textContent = 'Active';
                })
                .catch(error => {
                    console.error('Error loading stats:', error);
                    document.getElementById('totalThreats').textContent = 'Error';
                });
        }

        function loadRecentThreats() {
            fetch('/api/dashboard/threats/recent?limit=5')
                .then(response => response.json())
                .then(data => {
                    const container = document.getElementById('recentThreats');
                    
                    if (data.threats && data.threats.length > 0) {
                        container.innerHTML = data.threats.map(threat => {
                            const severityClass = threat.severity ? `threat-${threat.severity.toLowerCase()}` : 'threat-low';
                            return `
                                <div class="threat-item ${severityClass}">
                                    <strong>${threat.category || 'Unknown'}</strong><br>
                                    ${threat.description || 'No description available'}<br>
                                    <small>Severity: ${threat.severity || 'Unknown'} | ${threat.timestamp || ''}</small>
                                </div>
                            `;
                        }).join('');
                    } else {
                        container.innerHTML = '<div class="threat-item">No recent threats detected.</div>';
                    }
                })
                .catch(error => {
                    console.error('Error loading threats:', error);
                    document.getElementById('recentThreats').innerHTML = 
                        '<div class="threat-item">Error loading threat data.</div>';
                });
        }

        function loadCategories() {
            fetch('/api/dashboard/threats/categories')
                .then(response => response.json())
                .then(data => {
                    if (data.categories && Object.keys(data.categories).length > 0) {
                        const categories = Object.keys(data.categories);
                        const counts = Object.values(data.categories);
                        
                        categoriesChart.data.labels = categories;
                        categoriesChart.data.datasets[0].data = counts;
                        categoriesChart.update('active');
                    } else {
                        // Show sample data if no real data available
                        categoriesChart.data.labels = ['Malware', 'Phishing', 'DDoS', 'Ransomware', 'APT'];
                        categoriesChart.data.datasets[0].data = [25, 18, 12, 8, 15];
                        categoriesChart.update('active');
                    }
                })
                .catch(error => {
                    console.error('Error loading categories:', error);
                    // Show sample data on error
                    categoriesChart.data.labels = ['Malware', 'Phishing', 'DDoS', 'Ransomware', 'APT'];
                    categoriesChart.data.datasets[0].data = [25, 18, 12, 8, 15];
                    categoriesChart.update('active');
                });
        }

        function loadSeverityData() {
            fetch('/api/dashboard/threats/severity/realtime')
                .then(response => response.json())
                .then(data => {
                    const realtimeData = data.realtime_severity;
                    
                    if (realtimeData) {
                        // Update severity distribution chart
                        const severityOrder = ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'INFO'];
                        const severityData = severityOrder.map(level => 
                            realtimeData.current_distribution[level] || 0
                        );
                        
                        severityChart.data.datasets[0].data = severityData;
                        severityChart.update('active');
                        
                        // Update time series chart
                        if (realtimeData.time_series && realtimeData.time_series.length > 0) {
                            const timeLabels = realtimeData.time_series.map(item => item.timestamp);
                            const criticalData = realtimeData.time_series.map(item => item.critical);
                            const highData = realtimeData.time_series.map(item => item.high);
                            const mediumData = realtimeData.time_series.map(item => item.medium);
                            
                            severityTimeSeriesChart.data.labels = timeLabels;
                            severityTimeSeriesChart.data.datasets[0].data = criticalData;
                            severityTimeSeriesChart.data.datasets[1].data = highData;
                            severityTimeSeriesChart.data.datasets[2].data = mediumData;
                            severityTimeSeriesChart.update('active');
                        }
                        
                        // Update metrics
                        if (realtimeData.trends) {
                            document.getElementById('criticalRate').textContent = realtimeData.trends.critical_rate + '%';
                            document.getElementById('threatVelocity').textContent = realtimeData.trends.threat_velocity + '/min';
                            document.getElementById('detectionAccuracy').textContent = realtimeData.trends.detection_accuracy + '%';
                        }
                        
                        if (realtimeData.alerts) {
                            document.getElementById('activeIncidents').textContent = realtimeData.alerts.active_incidents;
                            document.getElementById('blockedAttacks').textContent = realtimeData.alerts.blocked_attacks;
                        }
                    }
                })
                .catch(error => {
                    console.error('Error loading severity data:', error);
                    // Show sample data
                    severityChart.data.datasets[0].data = [12, 25, 35, 45, 78];
                    severityChart.update('active');
                });
        }

        function loadAdvancedStats() {
            fetch('/api/dashboard/stats/advanced')
                .then(response => response.json())
                .then(data => {
                    const advancedStats = data.advanced_stats;
                    
                    if (advancedStats) {
                        // Update attack vectors chart
                        if (advancedStats.attack_vectors) {
                            const vectorLabels = advancedStats.attack_vectors.map(v => v.vector);
                            const vectorCounts = advancedStats.attack_vectors.map(v => v.count);
                            
                            attackVectorsChart.data.labels = vectorLabels;
                            attackVectorsChart.data.datasets[0].data = vectorCounts;
                            attackVectorsChart.update('active');
                        }
                        
                        // Update geographic distribution
                        if (advancedStats.geographic_distribution) {
                            const geoLabels = advancedStats.geographic_distribution.map(g => g.country);
                            const threatCounts = advancedStats.geographic_distribution.map(g => g.threats);
                            const blockedCounts = advancedStats.geographic_distribution.map(g => g.blocked);
                            
                            geoDistributionChart.data.labels = geoLabels;
                            geoDistributionChart.data.datasets[0].data = threatCounts;
                            geoDistributionChart.data.datasets[1].data = blockedCounts;
                            geoDistributionChart.update('active');
                        }
                        
                        // Update hourly activity
                        if (advancedStats.hourly_patterns) {
                            const hourLabels = advancedStats.hourly_patterns.map(h => h.hour);
                            const threatsByHour = advancedStats.hourly_patterns.map(h => h.threats);
                            const blockedByHour = advancedStats.hourly_patterns.map(h => h.blocked);
                            
                            hourlyActivityChart.data.labels = hourLabels;
                            hourlyActivityChart.data.datasets[0].data = threatsByHour;
                            hourlyActivityChart.data.datasets[1].data = blockedByHour;
                            hourlyActivityChart.update('active');
                        }
                        
                        // Update system metrics
                        if (advancedStats.system_performance) {
                            const sysPerf = advancedStats.system_performance;
                            document.getElementById('systemCPU').textContent = sysPerf.cpu_usage + '%';
                            document.getElementById('memoryUsage').textContent = sysPerf.memory_usage + '%';
                            document.getElementById('networkThroughput').textContent = sysPerf.network_throughput + ' MB/s';
                            document.getElementById('activeConnections').textContent = sysPerf.active_connections;
                            
                            // Update progress bars
                            document.getElementById('memoryProgress').style.width = sysPerf.memory_usage + '%';
                        }
                        
                        // Update threat intelligence metrics
                        if (advancedStats.threat_intelligence) {
                            const threatIntel = advancedStats.threat_intelligence;
                            document.getElementById('iocFeeds').textContent = threatIntel.ioc_feeds;
                            document.getElementById('feedHealth').textContent = threatIntel.feed_health + '%';
                            document.getElementById('dataFreshness').textContent = threatIntel.data_freshness + ' min';
                        }
                    }
                })
                .catch(error => {
                    console.error('Error loading advanced stats:', error);
                });
        }

        function toggleSeverityRealtime() {
            const button = document.getElementById('severityRealtimeBtn');
            
            if (!isSeverityRealtimeActive) {
                // Start real-time updates
                isSeverityRealtimeActive = true;
                button.textContent = 'Stop Real-time';
                button.style.background = 'linear-gradient(135deg, #dc3545 0%, #e83e8c 100%)';
                
                severityRealtimeInterval = setInterval(() => {
                    loadSeverityData();
                }, 5000); // Update every 5 seconds
            } else {
                // Stop real-time updates
                isSeverityRealtimeActive = false;
                button.textContent = 'Start Real-time';
                button.style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';
                
                if (severityRealtimeInterval) {
                    clearInterval(severityRealtimeInterval);
                }
            }
        }

        function toggleAdvancedRealtime() {
            const button = document.getElementById('advancedRealtimeBtn');
            
            if (!isAdvancedRealtimeActive) {
                // Start real-time monitoring
                isAdvancedRealtimeActive = true;
                button.textContent = 'Stop Monitoring';
                button.style.background = 'linear-gradient(135deg, #dc3545 0%, #e83e8c 100%)';
                
                advancedRealtimeInterval = setInterval(() => {
                    loadAdvancedStats();
                }, 10000); // Update every 10 seconds
            } else {
                // Stop real-time monitoring
                isAdvancedRealtimeActive = false;
                button.textContent = 'Start Monitoring';
                button.style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';
                
                if (advancedRealtimeInterval) {
                    clearInterval(advancedRealtimeInterval);
                }
            }
        }

        function resetSeverityChart() {
            severityChart.data.datasets[0].data = [0, 0, 0, 0, 0];
            severityChart.update('active');
            
            severityTimeSeriesChart.data.labels = [];
            severityTimeSeriesChart.data.datasets.forEach(dataset => {
                dataset.data = [];
            });
            severityTimeSeriesChart.update('active');
        }

        function refreshAdvancedStats() {
            loadAdvancedStats();
        }

        function exportChart(chartType) {
            let chart;
            let filename;
            
            switch(chartType) {
                case 'categories':
                    chart = categoriesChart;
                    filename = 'threat_categories_chart.png';
                    break;
                case 'severity':
                    chart = severityChart;
                    filename = 'severity_distribution_chart.png';
                    break;
                case 'realtime':
                    chart = hourlyActivityChart;
                    filename = 'realtime_statistics_chart.png';
                    break;
                case 'attack_vectors':
                    chart = attackVectorsChart;
                    filename = 'attack_vectors_chart.png';
                    break;
                case 'geographic':
                    chart = geoDistributionChart;
                    filename = 'geographic_distribution_chart.png';
                    break;
                case 'hourly':
                    chart = hourlyActivityChart;
                    filename = 'hourly_activity_chart.png';
                    break;
                default:
                    return;
            }
            
            if (chart) {
                const url = chart.toBase64Image();
                const link = document.createElement('a');
                link.download = filename;
                link.href = url;
                link.click();
            }
        }

        // Enhanced Active Chart Functions
        function startAttackVectorsLiveMode() {
            if (!window.attackVectorsInterval) {
                window.attackVectorsInterval = setInterval(() => {
                    updateAttackVectorsChart();
                }, 8000); // Update every 8 seconds
                
                document.getElementById('attackVectorsLiveBtn').textContent = 'Stop Live Mode';
                document.getElementById('attackVectorsLiveBtn').style.background = 'linear-gradient(135deg, #dc3545 0%, #e83e8c 100%)';
                console.log('Attack Vectors live mode started');
            } else {
                clearInterval(window.attackVectorsInterval);
                window.attackVectorsInterval = null;
                document.getElementById('attackVectorsLiveBtn').textContent = 'Start Live Mode';
                document.getElementById('attackVectorsLiveBtn').style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';
                console.log('Attack Vectors live mode stopped');
            }
        }

        function updateAttackVectorsChart() {
            // Fetch live attack vectors data from API
            fetch('/api/dashboard/live/attack-vectors')
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        console.error('Attack Vectors API error:', data.error);
                        // Fallback to simulated data
                        updateAttackVectorsWithSimulatedData();
                        return;
                    }
                    
                    // Process API data
                    const vectors = data.vectors;
                    const labels = Object.keys(vectors).map(key => {
                        // Convert snake_case to Title Case
                        return key.split('_')
                                  .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                                  .join(' ');
                    });
                    const values = Object.values(vectors);
                    
                    // Update chart data
                    attackVectorsChart.data.labels = labels;
                    attackVectorsChart.data.datasets[0].data = values;
                    attackVectorsChart.data.datasets[0].backgroundColor = values.map(value => {
                        if (value > 200) return '#dc3545';  // Critical (>200)
                        if (value > 150) return '#fd7e14';  // High (151-200)
                        if (value > 100) return '#ffc107';  // Medium (101-150)
                        return '#28a745';                   // Low (‚â§100)
                    });
                    
                    attackVectorsChart.update('active');
                    
                    // Update detailed metrics
                    const totalThreats = data.total_attacks;
                    const threatCount = data.threat_count;
                    const analysisTime = data.analysis_period;
                    const highestThreat = Math.max(...values);
                    const avgThreat = Math.round(totalThreats / values.length);
                    
                    // Find most dangerous vector
                    const maxIndex = values.indexOf(highestThreat);
                    const mostDangerous = labels[maxIndex];
                    
                    // Display comprehensive attack vectors information
                    displayAttackVectorsInfo({
                        totalThreats,
                        threatCount,
                        analysisTime,
                        highestThreat,
                        avgThreat,
                        mostDangerous,
                        vectors: Object.fromEntries(labels.map((label, i) => [label, values[i]])),
                        timestamp: data.timestamp
                    });
                    
                    console.log(`Attack Vectors Updated: Total=${totalThreats}, Analysis=${threatCount} threats, Period=${analysisTime}, Top=${mostDangerous}(${highestThreat})`);
                })
                .catch(error => {
                    console.error('Attack Vectors fetch error:', error);
                    updateAttackVectorsWithSimulatedData();
                });
        }
        
        function updateAttackVectorsWithSimulatedData() {
            // Fallback simulated data
            const attackTypes = ['Malware', 'Phishing', 'DDoS', 'SQL Injection', 'Brute Force', 'Privilege Escalation', 'Social Engineering', 'Ransomware'];
            const newData = attackTypes.map(() => Math.floor(Math.random() * 150) + 50);
            
            attackVectorsChart.data.labels = attackTypes;
            attackVectorsChart.data.datasets[0].data = newData;
            attackVectorsChart.data.datasets[0].backgroundColor = newData.map(value => {
                if (value > 120) return '#dc3545';
                if (value > 90) return '#fd7e14';
                if (value > 60) return '#ffc107';
                return '#28a745';
            });
            
            attackVectorsChart.update('active');
            
            const totalThreats = newData.reduce((a, b) => a + b, 0);
            const highestThreat = Math.max(...newData);
            const avgThreat = Math.round(totalThreats / newData.length);
            const mostDangerous = attackTypes[newData.indexOf(highestThreat)];
            
            displayAttackVectorsInfo({
                totalThreats,
                threatCount: Math.floor(Math.random() * 50) + 20,
                analysisTime: '1 hour',
                highestThreat,
                avgThreat,
                mostDangerous,
                vectors: Object.fromEntries(attackTypes.map((type, i) => [type, newData[i]])),
                timestamp: new Date().toISOString()
            });
            
            console.log(`Attack Vectors Updated (Simulated): Total=${totalThreats}, Highest=${highestThreat}, Avg=${avgThreat}`);
        }
        
        function displayAttackVectorsInfo(data) {
            // Create or update attack vectors information panel
            let infoPanel = document.getElementById('attackVectorsInfo');
            if (!infoPanel) {
                // Create info panel if it doesn't exist
                const chartContainer = document.querySelector('#attackVectorsChartContainer');
                if (chartContainer) {
                    infoPanel = document.createElement('div');
                    infoPanel.id = 'attackVectorsInfo';
                    infoPanel.className = 'attack-vectors-info mt-3';
                    chartContainer.appendChild(infoPanel);
                }
            }
            
            if (infoPanel) {
                const severityColor = data.highestThreat > 200 ? '#dc3545' : 
                                    data.highestThreat > 150 ? '#fd7e14' : 
                                    data.highestThreat > 100 ? '#ffc107' : '#28a745';
                
                // Sort vectors by threat count for display
                const sortedVectors = Object.entries(data.vectors)
                    .sort(([,a], [,b]) => b - a)
                    .slice(0, 5); // Top 5 vectors
                
                infoPanel.innerHTML = `
                    <div class="row">
                        <div class="col-md-6">
                            <div class="info-card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 15px; border-radius: 8px; margin-bottom: 10px;">
                                <h6><i class="fas fa-shield-alt"></i> Threat Analysis Summary</h6>
                                <div class="row">
                                    <div class="col-6">
                                        <small>Total Attacks</small><br>
                                        <strong style="font-size: 1.2em;">${data.totalThreats.toLocaleString()}</strong>
                                    </div>
                                    <div class="col-6">
                                        <small>Analysis Period</small><br>
                                        <strong>${data.analysisTime}</strong>
                                    </div>
                                </div>
                                <div class="row mt-2">
                                    <div class="col-6">
                                        <small>Average per Vector</small><br>
                                        <strong>${data.avgThreat}</strong>
                                    </div>
                                    <div class="col-6">
                                        <small>Data Sources</small><br>
                                        <strong>${data.threatCount} feeds</strong>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="info-card" style="background: linear-gradient(135deg, ${severityColor}, ${severityColor}dd); color: white; padding: 15px; border-radius: 8px; margin-bottom: 10px;">
                                <h6><i class="fas fa-exclamation-triangle"></i> Primary Threat Vector</h6>
                                <div style="font-size: 1.1em; margin-bottom: 8px;">
                                    <strong>${data.mostDangerous}</strong>
                                </div>
                                <div class="row">
                                    <div class="col-6">
                                        <small>Threat Count</small><br>
                                        <strong style="font-size: 1.3em;">${data.highestThreat}</strong>
                                    </div>
                                    <div class="col-6">
                                        <small>Risk Level</small><br>
                                        <strong>${data.highestThreat > 200 ? 'CRITICAL' : data.highestThreat > 150 ? 'HIGH' : data.highestThreat > 100 ? 'MEDIUM' : 'LOW'}</strong>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="top-vectors mt-2">
                        <h6><i class="fas fa-list-ol"></i> Top Attack Vectors</h6>
                        <div class="row">
                            ${sortedVectors.map(([vector, count], index) => `
                                <div class="col-md-2 col-sm-4 col-6 mb-2">
                                    <div class="vector-item" style="background: ${count > 200 ? '#dc354520' : count > 150 ? '#fd7e1420' : count > 100 ? '#ffc10720' : '#28a74520'}; 
                                         border-left: 3px solid ${count > 200 ? '#dc3545' : count > 150 ? '#fd7e14' : count > 100 ? '#ffc107' : '#28a745'}; 
                                         padding: 8px; border-radius: 4px; text-align: center;">
                                        <small style="font-weight: bold;">#${index + 1}</small><br>
                                        <small>${vector}</small><br>
                                        <strong style="color: ${count > 200 ? '#dc3545' : count > 150 ? '#fd7e14' : count > 100 ? '#ffc107' : '#28a745'};">${count}</strong>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                    <div class="text-muted mt-2" style="font-size: 0.8em;">
                        <i class="fas fa-clock"></i> Last updated: ${new Date(data.timestamp).toLocaleString()}
                    </div>
                `;
            }
        }

        function startGeographicLiveMode() {
            if (!window.geographicInterval) {
                window.geographicInterval = setInterval(() => {
                    updateGeographicChart();
                }, 12000); // Update every 12 seconds
                
                document.getElementById('geographicLiveBtn').textContent = 'Stop Live Mode';
                document.getElementById('geographicLiveBtn').style.background = 'linear-gradient(135deg, #dc3545 0%, #e83e8c 100%)';
                console.log('Geographic Distribution live mode started');
            } else {
                clearInterval(window.geographicInterval);
                window.geographicInterval = null;
                document.getElementById('geographicLiveBtn').textContent = 'Start Live Mode';
                document.getElementById('geographicLiveBtn').style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';
                console.log('Geographic Distribution live mode stopped');
            }
        }

        function updateGeographicChart() {
            const countries = ['United States', 'China', 'Russia', 'Brazil', 'India', 'Germany', 'United Kingdom', 'France'];
            const threatsData = countries.map(() => Math.floor(Math.random() * 200) + 50);
            const blockedData = threatsData.map(threats => Math.floor(threats * (Math.random() * 0.4 + 0.6))); // 60-100% blocked
            
            geoDistributionChart.data.labels = countries;
            geoDistributionChart.data.datasets[0].data = threatsData;
            geoDistributionChart.data.datasets[1].data = blockedData;
            geoDistributionChart.update('active');
            
            // Calculate and display blocking efficiency
            const totalThreats = threatsData.reduce((a, b) => a + b, 0);
            const totalBlocked = blockedData.reduce((a, b) => a + b, 0);
            const blockingRate = ((totalBlocked / totalThreats) * 100).toFixed(1);
            
            console.log(`Geographic Updated: ${totalThreats} threats, ${totalBlocked} blocked (${blockingRate}% efficiency)`);
        }

        function startHourlyActivityLiveMode() {
            if (!window.hourlyActivityInterval) {
                window.hourlyActivityInterval = setInterval(() => {
                    updateHourlyActivityChart();
                }, 15000); // Update every 15 seconds
                
                document.getElementById('hourlyActivityLiveBtn').textContent = 'Stop Live Mode';
                document.getElementById('hourlyActivityLiveBtn').style.background = 'linear-gradient(135deg, #dc3545 0%, #e83e8c 100%)';
                console.log('Hourly Activity live mode started');
            } else {
                clearInterval(window.hourlyActivityInterval);
                window.hourlyActivityInterval = null;
                document.getElementById('hourlyActivityLiveBtn').textContent = 'Start Live Mode';
                document.getElementById('hourlyActivityLiveBtn').style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';
                console.log('Hourly Activity live mode stopped');
            }
        }

        function updateHourlyActivityChart() {
            const currentHour = new Date().getHours();
            const hours = [];
            const threatsData = [];
            const blockedData = [];
            
            // Generate 24 hours of data with realistic patterns
            for (let i = 0; i < 24; i++) {
                const hour = (currentHour - 23 + i + 24) % 24;
                hours.push(`${hour.toString().padStart(2, '0')}:00`);
                
                // Business hours have more activity
                let baseActivity = 50;
                if (hour >= 9 && hour <= 17) {
                    baseActivity = 150;  // Business hours
                } else if (hour >= 18 && hour <= 22) {
                    baseActivity = 100;  // Evening
                } else {
                    baseActivity = 30;   // Night/early morning
                }
                
                // Add some randomness
                const threats = Math.floor(baseActivity * (Math.random() * 0.6 + 0.7));
                const blocked = Math.floor(threats * (Math.random() * 0.3 + 0.7)); // 70-100% blocked
                
                threatsData.push(threats);
                blockedData.push(blocked);
            }
            
            hourlyActivityChart.data.labels = hours;
            hourlyActivityChart.data.datasets[0].data = threatsData;
            hourlyActivityChart.data.datasets[1].data = blockedData;
            hourlyActivityChart.update('active');
            
            const currentThreats = threatsData[23]; // Latest hour
            const currentBlocked = blockedData[23];
            const currentRate = ((currentBlocked / currentThreats) * 100).toFixed(1);
            
            console.log(`Hourly Activity Updated: Current hour ${currentThreats} threats, ${currentBlocked} blocked (${currentRate}%)`);
        }

        // Enhanced chart interaction functions
        function resetAllCharts() {
            // Reset all charts to initial state
            const charts = [categoriesChart, severityChart, severityTimeSeriesChart, attackVectorsChart, geoDistributionChart, hourlyActivityChart];
            
            charts.forEach(chart => {
                if (chart) {
                    chart.data.datasets.forEach(dataset => {
                        dataset.data = [];
                    });
                    chart.data.labels = [];
                    chart.update('none'); // No animation for reset
                }
            });
            
            console.log('All charts reset');
        }

        function pauseAllLiveModes() {
            // Stop all live chart updates
            const intervals = [
                'attackVectorsInterval',
                'geographicInterval', 
                'hourlyActivityInterval',
                'severityRealtimeInterval',
                'advancedRealtimeInterval'
            ];
            
            intervals.forEach(intervalName => {
                if (window[intervalName]) {
                    clearInterval(window[intervalName]);
                    window[intervalName] = null;
                }
            });
            
            // Reset button states
            const buttons = [
                'attackVectorsLiveBtn',
                'geographicLiveBtn',
                'hourlyActivityLiveBtn',
                'severityRealtimeBtn',
                'advancedRealtimeBtn'
            ];
            
            buttons.forEach(btnId => {
                const btn = document.getElementById(btnId);
                if (btn) {
                    btn.textContent = btn.textContent.replace('Stop', 'Start');
                    btn.style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';
                }
            });
            
            console.log('All live modes paused');
        }

        function startAllLiveModes() {
            // Start all chart live modes
            if (document.getElementById('attackVectorsLiveBtn')) startAttackVectorsLiveMode();
            if (document.getElementById('geographicLiveBtn')) startGeographicLiveMode();
            if (document.getElementById('hourlyActivityLiveBtn')) startHourlyActivityLiveMode();
            toggleSeverityRealtime();
            toggleAdvancedRealtime();
            
            console.log('All live modes started');
        }

        // Chart drill-down functionality
        function onChartClick(chart, event) {
            const points = chart.getElementsAtEventForMode(event, 'nearest', { intersect: true }, true);
            
            if (points.length) {
                const firstPoint = points[0];
                const label = chart.data.labels[firstPoint.index];
                const value = chart.data.datasets[firstPoint.datasetIndex].data[firstPoint.index];
                
                console.log(`Chart clicked: ${label} = ${value}`);
                
                // Show detailed information modal (could be enhanced further)
                alert(`Detailed Info:\nCategory: ${label}\nValue: ${value}\nClick timestamp: ${new Date().toLocaleTimeString()}`);
            }
        }

        // Enhanced chart tooltips
        function createAdvancedTooltips() {
            Chart.defaults.plugins.tooltip.callbacks.title = function(tooltipItems) {
                return tooltipItems[0].label + ' - Live Data';
            };
            
            Chart.defaults.plugins.tooltip.callbacks.label = function(context) {
                const label = context.dataset.label || '';
                const value = context.parsed.y || context.parsed;
                const percentage = context.dataset.data.length > 0 ? 
                    ((value / context.dataset.data.reduce((a, b) => a + b, 0)) * 100).toFixed(1) : 0;
                
                return `${label}: ${value} (${percentage}%)`;
            };
        }

        // Active System Health Monitor Functions
        function startSystemHealthLiveMode() {
            if (!isSystemHealthLive) {
                isSystemHealthLive = true;
                document.getElementById('systemHealthLiveBtn').textContent = 'Stop Health Monitor';
                document.getElementById('systemHealthLiveBtn').style.background = 'linear-gradient(135deg, #dc3545 0%, #e83e8c 100%)';
                
                systemHealthInterval = setInterval(() => {
                    updateSystemHealthCharts();
                }, 6000); // Update every 6 seconds
                
                console.log('System Health monitoring started');
            } else {
                stopSystemHealthLiveMode();
            }
        }

        function stopSystemHealthLiveMode() {
            isSystemHealthLive = false;
            document.getElementById('systemHealthLiveBtn').textContent = 'Start Health Monitor';
            document.getElementById('systemHealthLiveBtn').style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';
            
            if (systemHealthInterval) {
                clearInterval(systemHealthInterval);
                systemHealthInterval = null;
            }
            
            console.log('System Health monitoring stopped');
        }

        function updateSystemHealthCharts() {
            // Generate realistic system performance data
            const currentTime = new Date().toLocaleTimeString();
            
            // CPU usage with realistic patterns
            const cpuUsage = Math.floor(Math.random() * 30 + 15); // 15-45%
            const memoryUsage = Math.floor(Math.random() * 35 + 40); // 40-75%
            const diskUsage = Math.floor(Math.random() * 20 + 25); // 25-45%
            
            // Update progress bars
            document.getElementById('cpuUsageLive').textContent = cpuUsage + '%';
            document.getElementById('cpuProgress').style.width = cpuUsage + '%';
            
            document.getElementById('memoryUsageLive').textContent = memoryUsage + '%';
            document.getElementById('memoryProgressLive').style.width = memoryUsage + '%';
            
            document.getElementById('diskUsage').textContent = diskUsage + '%';
            document.getElementById('diskProgress').style.width = diskUsage + '%';
            
            // Update network metrics
            const networkThroughput = Math.floor(Math.random() * 150 + 50);
            const activeConnections = Math.floor(Math.random() * 2000 + 1000);
            
            document.getElementById('networkThroughputLive').textContent = networkThroughput + ' MB/s';
            document.getElementById('activeConnectionsLive').textContent = activeConnections;
            
            // Update system uptime
            const uptimeDays = Math.floor(Math.random() * 25 + 5);
            document.getElementById('systemUptime').textContent = uptimeDays + ' days';
            
            // Update system health timeline chart
            const maxDataPoints = 20;
            
            // Add new data point
            if (systemHealthChart.data.labels.length >= maxDataPoints) {
                systemHealthChart.data.labels.shift();
                systemHealthChart.data.datasets.forEach(dataset => dataset.data.shift());
            }
            
            systemHealthChart.data.labels.push(currentTime);
            systemHealthChart.data.datasets[0].data.push(cpuUsage);
            systemHealthChart.data.datasets[1].data.push(memoryUsage);
            systemHealthChart.data.datasets[2].data.push(diskUsage);
            systemHealthChart.update('active');
            
            // Update resource distribution chart
            const available = 100 - memoryUsage;
            const system = Math.floor(memoryUsage * 0.3);
            const applications = Math.floor(memoryUsage * 0.5);
            const cache = memoryUsage - system - applications;
            
            resourceDistributionChart.data.datasets[0].data = [available, system, applications, cache];
            resourceDistributionChart.update('active');
            
            console.log(`System Health Updated: CPU: ${cpuUsage}%, Memory: ${memoryUsage}%, Disk: ${diskUsage}%`);
        }

        function refreshSystemHealth() {
            updateSystemHealthCharts();
        }

        // Active Threat Intelligence Feeds Functions
        function startThreatFeedsLiveMode() {
            if (!isThreatFeedsLive) {
                isThreatFeedsLive = true;
                document.getElementById('threatFeedsLiveBtn').textContent = 'Stop Feed Monitor';
                document.getElementById('threatFeedsLiveBtn').style.background = 'linear-gradient(135deg, #dc3545 0%, #e83e8c 100%)';
                
                threatFeedsInterval = setInterval(() => {
                    updateThreatFeedsCharts();
                }, 8000); // Update every 8 seconds
                
                console.log('Threat Intelligence Feeds monitoring started');
            } else {
                stopThreatFeedsLiveMode();
            }
        }

        function stopThreatFeedsLiveMode() {
            isThreatFeedsLive = false;
            document.getElementById('threatFeedsLiveBtn').textContent = 'Start Feed Monitor';
            document.getElementById('threatFeedsLiveBtn').style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';
            
            if (threatFeedsInterval) {
                clearInterval(threatFeedsInterval);
                threatFeedsInterval = null;
            }
            
            console.log('Threat Intelligence Feeds monitoring stopped');
        }

        function updateThreatFeedsCharts() {
            const currentTime = new Date().toLocaleTimeString();
            
            // Generate realistic feed data
            const activeFeedsCount = Math.floor(Math.random() * 20 + 80); // 80-100 feeds
            const feedHealthScore = Math.floor(Math.random() * 10 + 90); // 90-100% health
            const dataFreshness = Math.floor(Math.random() * 10 + 1); // 1-10 minutes
            
            // Update main metrics
            document.getElementById('iocFeedsLive').textContent = activeFeedsCount;
            document.getElementById('feedHealthLive').textContent = feedHealthScore + '%';
            document.getElementById('feedHealthProgress').style.width = feedHealthScore + '%';
            document.getElementById('dataFreshnessLive').textContent = dataFreshness + ' min';
            
            // Update performance metrics
            const totalIOCs = Math.floor(Math.random() * 5000 + 15000);
            const updateRate = Math.floor(Math.random() * 15 + 5);
            const correlationRate = Math.floor(Math.random() * 15 + 75);
            
            document.getElementById('totalIOCs').textContent = totalIOCs.toLocaleString();
            document.getElementById('feedUpdateRate').textContent = updateRate + '/min';
            document.getElementById('correlationRate').textContent = correlationRate + '%';
            
            // Update feed status timeline
            const maxDataPoints = 15;
            
            if (feedStatusChart.data.labels.length >= maxDataPoints) {
                feedStatusChart.data.labels.shift();
                feedStatusChart.data.datasets.forEach(dataset => dataset.data.shift());
            }
            
            feedStatusChart.data.labels.push(currentTime);
            feedStatusChart.data.datasets[0].data.push(feedHealthScore);
            feedStatusChart.data.datasets[1].data.push(activeFeedsCount);
            feedStatusChart.update('active');
            
            // Update IOC types distribution
            const iocTypes = [
                Math.floor(Math.random() * 500 + 1000), // IP Addresses
                Math.floor(Math.random() * 300 + 700),  // Domains
                Math.floor(Math.random() * 400 + 800),  // URLs
                Math.floor(Math.random() * 200 + 500),  // File Hashes
                Math.floor(Math.random() * 150 + 300),  // Email Addresses
                Math.floor(Math.random() * 100 + 200)   // CVEs
            ];
            
            iocTypesChart.data.datasets[0].data = iocTypes;
            iocTypesChart.update('active');
            
            // Update feed sources table
            updateFeedSourcesTable();
            
            console.log(`Threat Feeds Updated: ${activeFeedsCount} feeds, ${feedHealthScore}% health, ${dataFreshness}min freshness`);
        }

        function updateFeedSourcesTable() {
            const feedSources = [
                { name: 'MISP Community', status: 'Active', iocs: Math.floor(Math.random() * 1000 + 2000), lastUpdate: '2 min ago', health: Math.floor(Math.random() * 10 + 90) },
                { name: 'AlienVault OTX', status: 'Active', iocs: Math.floor(Math.random() * 800 + 1500), lastUpdate: '5 min ago', health: Math.floor(Math.random() * 10 + 85) },
                { name: 'VirusTotal', status: 'Active', iocs: Math.floor(Math.random() * 600 + 1200), lastUpdate: '3 min ago', health: Math.floor(Math.random() * 15 + 85) },
                { name: 'Threat Fox', status: 'Active', iocs: Math.floor(Math.random() * 400 + 800), lastUpdate: '1 min ago', health: Math.floor(Math.random() * 10 + 90) },
                { name: 'Abuse.ch', status: 'Active', iocs: Math.floor(Math.random() * 300 + 600), lastUpdate: '4 min ago', health: Math.floor(Math.random() * 15 + 80) },
                { name: 'EmergingThreats', status: 'Warning', iocs: Math.floor(Math.random() * 200 + 400), lastUpdate: '12 min ago', health: Math.floor(Math.random() * 20 + 70) }
            ];
            
            const tableBody = document.getElementById('feedTableBody');
            tableBody.innerHTML = feedSources.map(feed => {
                const statusColor = feed.status === 'Active' ? '#28a745' : '#ffc107';
                const healthColor = feed.health >= 90 ? '#28a745' : feed.health >= 80 ? '#ffc107' : '#dc3545';
                
                return `
                    <tr style="border-bottom: 1px solid #dee2e6;">
                        <td style="padding: 8px;">${feed.name}</td>
                        <td style="padding: 8px; text-align: center;">
                            <span style="color: ${statusColor}; font-weight: bold;">${feed.status}</span>
                        </td>
                        <td style="padding: 8px; text-align: center;">${feed.iocs.toLocaleString()}</td>
                        <td style="padding: 8px; text-align: center;">${feed.lastUpdate}</td>
                        <td style="padding: 8px; text-align: center;">
                            <span style="color: ${healthColor}; font-weight: bold;">${feed.health}%</span>
                        </td>
                    </tr>
                `;
            }).join('');
        }

        function refreshThreatFeeds() {
            updateThreatFeeds();
        }

        // ================================
        // ALERT SYSTEM & PUSH NOTIFICATIONS
        // ================================

        let notifications = [];
        let notificationId = 1;
        let isNotificationPanelOpen = false;
        let alertSystemInterval = null;
        let pushNotificationQueue = [];
        
        // Live Update System Variables
        let liveUpdateInterval = null;
        let realTimeAlertInterval = null;
        let threatIntelInterval = null;
        let systemStatusInterval = null;
        let isLiveUpdatesActive = true;
        let lastUpdateTime = new Date();
        let liveUpdateStats = {
            totalUpdates: 0,
            criticalAlerts: 0,
            warningAlerts: 0,
            infoAlerts: 0
        };

        // Initialize Alert System with Live Updates and Absolute Priority
        function initializeAlertSystem() {
            // Ensure notification container has absolute priority above all body elements
            ensureAbsolutePriority();
            
            // Start live notification updates
            startLiveNotificationUpdates();
            
            // Click outside to close panel
            document.addEventListener('click', function(event) {
                const alertSystem = document.querySelector('.alert-system');
                const notificationPanel = document.getElementById('notificationPanel');
                const notificationContainer = document.getElementById('notificationContainer');
                
                if (!alertSystem.contains(event.target) && 
                    !notificationContainer.contains(event.target) && 
                    isNotificationPanelOpen) {
                    closeNotificationPanel();
                }
            });

            // Request notification permission
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission();
            }

            console.log('Live Alert System initialized with real-time updates and absolute priority');
        }

        // ================================
        // LIVE CHARTS INFORMATION SYSTEM
        // ================================

        function startLiveChartsInformation() {
            if (isLiveChartsActive) {
                console.log('üî¥ Starting live charts information system...');
                
                // Live charts update interval (every 3-7 seconds)
                liveChartsInterval = setInterval(() => {
                    if (isLiveChartsActive) {
                        updateAllLiveCharts();
                    }
                }, Math.random() * 4000 + 3000);
                
                // Add live indicators to all charts
                addLiveIndicatorsToCharts();
                
                console.log('‚úÖ Live charts information system active');
            }
        }

        function stopLiveChartsInformation() {
            isLiveChartsActive = false;
            
            if (liveChartsInterval) {
                clearInterval(liveChartsInterval);
                liveChartsInterval = null;
            }
            
            removeLiveIndicatorsFromCharts();
            console.log('üî¥ Live charts information stopped');
        }

        function toggleLiveCharts() {
            if (isLiveChartsActive) {
                stopLiveChartsInformation();
            } else {
                isLiveChartsActive = true;
                startLiveChartsInformation();
            }
        }

        // Update all live charts with real-time information from backend APIs
        function updateAllLiveCharts() {
            updateAttackVectorsLive();
            updateGeographicDistributionLive();
            updateHourlyActivityPatternLive();
            
            // Update live information displays
            updateLiveChartsDisplay();
        }

        // ================================
        // ATTACK VECTORS LIVE
        // ================================

        function updateAttackVectorsLive() {
            // Fetch live attack vectors data from API
            fetch('/api/dashboard/live/attack-vectors')
                .then(response => response.json())
                .then(data => {
                    if (attackVectorsChart && attackVectorsChart.data) {
                        const vectors = data.vectors || {};
                        const malware = vectors.malware || 0;
                        const phishing = vectors.phishing || 0;
                        const bruteForce = vectors.brute_force || 0;
                        const sqlInjection = vectors.sql_injection || 0;
                        const ddos = vectors.ddos || 0;
                        const privilege = vectors.privilege_escalation || 0;
                        const socialEng = vectors.social_engineering || 0;
                        const ransomware = vectors.ransomware || 0;
                        
                        attackVectorsChart.data.datasets[0].data = [malware, phishing, bruteForce, sqlInjection, ddos, privilege, socialEng, ransomware];
                        attackVectorsChart.update('none');
                        
                        // Update live attack vectors information display
                        updateAttackVectorsLiveDisplay(malware, phishing, bruteForce, sqlInjection, ddos, privilege, data);
                        
                        chartLiveStats.attackVectorsUpdates++;
                        console.log(`üî¥ Attack Vectors Live API: Total:${data.total_attacks} Malware:${malware} Phishing:${phishing}`);
                    }
                })
                .catch(error => {
                    console.error('Error fetching attack vectors:', error);
                    // Fallback to simulated data if API fails
                    updateAttackVectorsLiveFallback();
                });
        }
        
        function updateAttackVectorsLiveFallback() {
            if (attackVectorsChart && attackVectorsChart.data) {
                // Generate realistic attack vector data as fallback
                const malware = Math.floor(Math.random() * 500 + 800); // 800-1300
                const phishing = Math.floor(Math.random() * 400 + 600); // 600-1000
                const bruteForce = Math.floor(Math.random() * 300 + 400); // 400-700
                const sqlInjection = Math.floor(Math.random() * 200 + 300); // 300-500
                const ddos = Math.floor(Math.random() * 150 + 200); // 200-350
                const privilege = Math.floor(Math.random() * 100 + 150); // 150-250
                
                attackVectorsChart.data.datasets[0].data = [malware, phishing, bruteForce, sqlInjection, ddos, privilege];
                attackVectorsChart.update('none');
                
                updateAttackVectorsLiveDisplay(malware, phishing, bruteForce, sqlInjection, ddos, privilege);
                
                chartLiveStats.attackVectorsUpdates++;
                console.log(`üî¥ Attack Vectors Live (Fallback): Malware:${malware} Phishing:${phishing} BruteForce:${bruteForce}`);
            }
        }

        function updateAttackVectorsLiveDisplay(malware, phishing, brute, sql, ddos, priv) {
            const chartContainer = document.querySelector('#attackVectorsChart')?.parentElement;
            if (chartContainer) {
                let liveInfoEl = chartContainer.querySelector('.chart-live-info');
                
                if (!liveInfoEl) {
                    liveInfoEl = document.createElement('div');
                    liveInfoEl.className = 'chart-live-info';
                    liveInfoEl.style.cssText = `
                        position: absolute;
                        top: 10px;
                        right: 10px;
                        background: rgba(220, 53, 69, 0.9);
                        color: white;
                        padding: 8px 12px;
                        border-radius: 6px;
                        font-size: 11px;
                        z-index: 1000;
                        max-width: 150px;
                    `;
                    chartContainer.style.position = 'relative';
                    chartContainer.appendChild(liveInfoEl);
                }
                
                const total = malware + phishing + brute + sql + ddos + priv;
                const topThreat = Math.max(malware, phishing, brute, sql, ddos, priv);
                let topThreatName = 'Malware';
                if (topThreat === phishing) topThreatName = 'Phishing';
                else if (topThreat === brute) topThreatName = 'Brute Force';
                else if (topThreat === sql) topThreatName = 'SQL Injection';
                else if (topThreat === ddos) topThreatName = 'DDoS';
                else if (topThreat === priv) topThreatName = 'Privilege Escalation';
                
                liveInfoEl.innerHTML = `
                    <div style="color: #fff;">üö® LIVE THREATS</div>
                    <div>Total: ${total.toLocaleString()}</div>
                    <div>Top: ${topThreatName}</div>
                    <div>Count: ${topThreat}</div>
                    <div style="font-size: 9px; opacity: 0.8;">Last: ${new Date().toLocaleTimeString()}</div>
                `;
            }
        }

        // ================================
        // GEOGRAPHIC DISTRIBUTION LIVE
        // ================================

        function updateGeographicDistributionLive() {
            // Fetch live geographic distribution data from API
            fetch('/api/dashboard/live/geographic-distribution')
                .then(response => response.json())
                .then(data => {
                    if (geoDistributionChart && geoDistributionChart.data) {
                        const regions = data.regions || {};
                        const regionNames = Object.keys(regions);
                        const threatCounts = Object.values(regions);
                        
                        // Update chart with top 6 regions
                        const topRegions = Object.entries(regions)
                            .sort(([,a], [,b]) => b - a)
                            .slice(0, 6);
                        
                        const labels = topRegions.map(([name, count]) => name);
                        const counts = topRegions.map(([name, count]) => count);
                        
                        geoDistributionChart.data.labels = labels;
                        geoDistributionChart.data.datasets[0].data = counts;
                        geoDistributionChart.update('none');
                        
                        // Update live geographic information display
                        updateGeographicDistributionLiveDisplay(labels, counts, data);
                        
                        chartLiveStats.geographicUpdates++;
                        console.log(`üî¥ Geographic Distribution Live API: Total:${data.total_threats} Top:${data.top_region[0]} (${data.top_region[1]})`);
                    }
                })
                .catch(error => {
                    console.error('Error fetching geographic distribution:', error);
                    updateGeographicDistributionLiveFallback();
                });
        }
        
        function updateGeographicDistributionLiveFallback() {
            if (geoDistributionChart && geoDistributionChart.data) {
                // Generate realistic geographic threat data as fallback
                const regions = ['USA', 'China', 'Russia', 'Germany', 'Brazil', 'India'];
                const threatCounts = regions.map(() => Math.floor(Math.random() * 800 + 200)); // 200-1000 per region
                
                geoDistributionChart.data.datasets[0].data = threatCounts;
                geoDistributionChart.update('none');
                
                updateGeographicDistributionLiveDisplay(regions, threatCounts);
                
                chartLiveStats.geographicUpdates++;
                console.log(`üî¥ Geographic Distribution Live (Fallback): ${regions[0]}:${threatCounts[0]} ${regions[1]}:${threatCounts[1]}`);
            }
        }

        function updateGeographicDistributionLiveDisplay(regions, counts) {
            const chartContainer = document.querySelector('#geoDistributionChart')?.parentElement;
            if (chartContainer) {
                let liveInfoEl = chartContainer.querySelector('.chart-live-info');
                
                if (!liveInfoEl) {
                    liveInfoEl = document.createElement('div');
                    liveInfoEl.className = 'chart-live-info';
                    liveInfoEl.style.cssText = `
                        position: absolute;
                        top: 10px;
                        left: 10px;
                        background: rgba(23, 162, 184, 0.9);
                        color: white;
                        padding: 8px 12px;
                        border-radius: 6px;
                        font-size: 11px;
                        z-index: 1000;
                        max-width: 140px;
                    `;
                    chartContainer.style.position = 'relative';
                    chartContainer.appendChild(liveInfoEl);
                }
                
                const total = counts.reduce((sum, count) => sum + count, 0);
                const topIndex = counts.indexOf(Math.max(...counts));
                
                liveInfoEl.innerHTML = `
                    <div style="color: #fff;">üåç LIVE GLOBAL THREATS</div>
                    <div>Total: ${total.toLocaleString()}</div>
                    <div>Hotspot: ${regions[topIndex]}</div>
                    <div>Count: ${counts[topIndex]}</div>
                    <div style="font-size: 9px; opacity: 0.8;">Regions: ${regions.length}</div>
                `;
            }
        }

        // ================================
        // HOURLY ACTIVITY PATTERN LIVE
        // ================================

        function updateHourlyActivityPatternLive() {
            // Fetch live hourly activity data from API
            fetch('/api/dashboard/live/hourly-activity')
                .then(response => response.json())
                .then(data => {
                    if (hourlyActivityChart && hourlyActivityChart.data) {
                        const hourlyData = data.hourly_data || {};
                        const currentHour = data.current_hour || new Date().getHours();
                        
                        // Convert hourly_data object to array
                        const activityArray = [];
                        for (let i = 0; i < 24; i++) {
                            activityArray.push(hourlyData[i] || 0);
                        }
                        
                        hourlyActivityChart.data.datasets[0].data = activityArray;
                        hourlyActivityChart.update('none');
                        
                        // Update live hourly activity information display
                        updateHourlyActivityLiveDisplay(activityArray, currentHour, data);
                        
                        chartLiveStats.hourlyActivityUpdates++;
                        console.log(`üî¥ Hourly Activity Live API: Current:${currentHour} Activity:${activityArray[currentHour]} Peak:${data.peak_hour}`);
                    }
                })
                .catch(error => {
                    console.error('Error fetching hourly activity:', error);
                    updateHourlyActivityPatternLiveFallback();
                });
        }
        
        function updateHourlyActivityPatternLiveFallback() {
            if (hourlyActivityChart && hourlyActivityChart.data) {
                const currentHour = new Date().getHours();
                
                // Generate realistic hourly activity pattern as fallback
                const hourlyData = [];
                for (let i = 0; i < 24; i++) {
                    // Simulate higher activity during business hours (8-18) and lower at night
                    let baseActivity = (i >= 8 && i <= 18) ? 600 : 200;
                    if (i >= 22 || i <= 6) baseActivity = 100; // Very low at night
                    
                    // Add current hour spike
                    if (i === currentHour) {
                        baseActivity += Math.floor(Math.random() * 300 + 200);
                    }
                    
                    hourlyData.push(baseActivity + Math.floor(Math.random() * 200));
                }
                
                hourlyActivityChart.data.datasets[0].data = hourlyData;
                hourlyActivityChart.update('none');
                
                updateHourlyActivityLiveDisplay(hourlyData, currentHour);
                
                chartLiveStats.hourlyActivityUpdates++;
                console.log(`üî¥ Hourly Activity Live (Fallback): Current Hour:${currentHour} Activity:${hourlyData[currentHour]}`);
            }
        }

        function updateHourlyActivityLiveDisplay(hourlyData, currentHour) {
            const chartContainer = document.querySelector('#hourlyActivityChart')?.parentElement;
            if (chartContainer) {
                let liveInfoEl = chartContainer.querySelector('.chart-live-info');
                
                if (!liveInfoEl) {
                    liveInfoEl = document.createElement('div');
                    liveInfoEl.className = 'chart-live-info';
                    liveInfoEl.style.cssText = `
                        position: absolute;
                        top: 10px;
                        right: 10px;
                        background: rgba(108, 117, 125, 0.9);
                        color: white;
                        padding: 8px 12px;
                        border-radius: 6px;
                        font-size: 11px;
                        z-index: 1000;
                        max-width: 160px;
                    `;
                    chartContainer.style.position = 'relative';
                    chartContainer.appendChild(liveInfoEl);
                }
                
                const currentActivity = hourlyData[currentHour];
                const totalToday = hourlyData.reduce((sum, activity) => sum + activity, 0);
                const peakHour = hourlyData.indexOf(Math.max(...hourlyData));
                
                liveInfoEl.innerHTML = `
                    <div style="color: #fff;">‚è∞ LIVE ACTIVITY</div>
                    <div>Current Hr: ${currentHour}:00</div>
                    <div>Activity: ${currentActivity}</div>
                    <div>Peak Hr: ${peakHour}:00</div>
                    <div>Today: ${totalToday.toLocaleString()}</div>
                `;
            }
        }

        // ================================
        // LIVE CHARTS DISPLAY MANAGEMENT
        // ================================

        function addLiveIndicatorsToCharts() {
            const chartContainers = [
                '#systemHealthChart',
                '#resourceDistributionChart', 
                '#attackVectorsChart',
                '#geoDistributionChart',
                '#hourlyActivityChart'
            ];
            
            chartContainers.forEach(selector => {
                const container = document.querySelector(selector)?.parentElement;
                if (container) {
                    let liveIndicator = container.querySelector('.live-indicator-chart');
                    
                    if (!liveIndicator) {
                        liveIndicator = document.createElement('div');
                        liveIndicator.className = 'live-indicator-chart';
                        liveIndicator.style.cssText = `
                            position: absolute;
                            top: 5px;
                            left: 5px;
                            background: #dc3545;
                            color: white;
                            padding: 2px 6px;
                            border-radius: 10px;
                            font-size: 9px;
                            font-weight: bold;
                            z-index: 1001;
                            animation: livePulse 2s infinite;
                        `;
                        liveIndicator.textContent = '‚óè LIVE';
                        container.style.position = 'relative';
                        container.appendChild(liveIndicator);
                    }
                }
            });
        }

        function removeLiveIndicatorsFromCharts() {
            const liveIndicators = document.querySelectorAll('.live-indicator-chart, .chart-live-info');
            liveIndicators.forEach(indicator => indicator.remove());
        }

        function updateLiveChartsDisplay() {
            // Update global live charts status
            const headerStatus = document.getElementById('realtimeStatusHeader');
            if (headerStatus) {
                if (isLiveChartsActive && isLiveUpdatesActive) {
                    headerStatus.textContent = 'Real-time: Active (Charts Live + Notifications Live)';
                } else if (isLiveChartsActive) {
                    headerStatus.textContent = 'Real-time: Active (Charts Live)';
                } else if (isLiveUpdatesActive) {
                    headerStatus.textContent = 'Real-time: Active (Notifications Live)';
                } else {
                    headerStatus.textContent = 'Real-time: Inactive';
                }
                headerStatus.className = (isLiveChartsActive || isLiveUpdatesActive) ? 'realtime-status realtime-active' : 'realtime-status realtime-inactive';
            }
            
            // Update live information dashboard counters
            updateLiveInfoDashboard();
            
            // Console log for monitoring
            console.log(`üî¥ Live Charts Update Complete - System:${chartLiveStats.systemPerformanceUpdates} Resource:${chartLiveStats.resourceDistributionUpdates} Attack:${chartLiveStats.attackVectorsUpdates} Geo:${chartLiveStats.geographicUpdates} Hourly:${chartLiveStats.hourlyActivityUpdates}`);
        }

        function updateLiveInfoDashboard() {
            // Update live counters in dashboard
            const elements = [
                { id: 'liveAttackVectors', value: chartLiveStats.attackVectorsUpdates },
                { id: 'liveGeographic', value: chartLiveStats.geographicUpdates },
                { id: 'liveHourlyActivity', value: chartLiveStats.hourlyActivityUpdates }
            ];
            
            elements.forEach(item => {
                const el = document.getElementById(item.id);
                if (el) {
                    el.textContent = item.value;
                    
                    // Add pulse animation on update
                    el.style.animation = 'pulse 0.5s ease-in-out';
                    setTimeout(() => {
                        el.style.animation = '';
                    }, 500);
                }
            });
            
            // Update status indicator
            const statusEl = document.getElementById('liveChartsStatus');
            if (statusEl) {
                if (isLiveChartsActive) {
                    statusEl.innerHTML = 'üî¥ ACTIVE';
                    statusEl.style.color = '#dc3545';
                } else {
                    statusEl.innerHTML = '‚ö´ PAUSED';
                    statusEl.style.color = '#6c757d';
                }
            }
        }

        // ================================
        // LIVE NOTIFICATION UPDATE SYSTEM
        // ================================

        function startLiveNotificationUpdates() {
            if (isLiveUpdatesActive) {
                console.log('üî¥ Starting live notification updates...');
                
                // Real-time threat alerts (every 8-18 seconds)
                realTimeAlertInterval = setInterval(() => {
                    if (isLiveUpdatesActive) {
                        generateRealtimeThreatAlert();
                    }
                }, Math.random() * 10000 + 8000);
                
                // Threat intelligence updates (every 30-60 seconds)
                threatIntelInterval = setInterval(() => {
                    if (isLiveUpdatesActive) {
                        generateThreatIntelUpdate();
                    }
                }, Math.random() * 30000 + 30000);
                
                // System status updates (every 45-90 seconds)
                systemStatusInterval = setInterval(() => {
                    if (isLiveUpdatesActive) {
                        generateSystemStatusUpdate();
                    }
                }, Math.random() * 45000 + 45000);
                
                // Live update monitor (every 2 seconds)
                liveUpdateInterval = setInterval(() => {
                    updateLiveStatus();
                    refreshNotificationTimestamps();
                }, 2000);
                
                // Add live status indicator to header
                updateHeaderLiveStatus();
                
                console.log('‚úÖ Live notification system active');
            }
        }

        function stopLiveNotificationUpdates() {
            isLiveUpdatesActive = false;
            
            if (realTimeAlertInterval) {
                clearInterval(realTimeAlertInterval);
                realTimeAlertInterval = null;
            }
            
            if (threatIntelInterval) {
                clearInterval(threatIntelInterval);
                threatIntelInterval = null;
            }
            
            if (systemStatusInterval) {
                clearInterval(systemStatusInterval);
                systemStatusInterval = null;
            }
            
            if (liveUpdateInterval) {
                clearInterval(liveUpdateInterval);
                liveUpdateInterval = null;
            }
            
            updateHeaderLiveStatus();
            console.log('üî¥ Live notification updates stopped');
        }

        function toggleLiveUpdates() {
            const toggleBtn = document.getElementById('liveToggleBtn');
            
            if (isLiveUpdatesActive) {
                stopLiveNotificationUpdates();
                toggleBtn.textContent = 'üì¥ Offline';
                toggleBtn.className = 'control-btn live-toggle-inactive';
                
                showPushNotification({
                    type: 'warning',
                    title: 'üì¥ Live Updates Paused',
                    message: 'Notification monitoring has been paused. Click "Live" to resume real-time alerts.'
                });
            } else {
                isLiveUpdatesActive = true;
                startLiveNotificationUpdates();
                toggleBtn.textContent = 'üì° Live';
                toggleBtn.className = 'control-btn live-toggle-active';
                
                showPushNotification({
                    type: 'info',
                    title: 'üì° Live Updates Active',
                    message: 'Real-time notification monitoring is now active. Security alerts will appear automatically.'
                });
            }
            
            updateLiveStatsDisplay();
        }

        function updateLiveStatsDisplay() {
            // Add/update live stats in notification panel
            let statsEl = document.getElementById('liveStats');
            
            if (!statsEl) {
                statsEl = document.createElement('div');
                statsEl.id = 'liveStats';
                statsEl.className = 'live-stats';
                
                const notificationList = document.getElementById('notificationList');
                notificationList.parentNode.appendChild(statsEl);
            }
            
            const uptime = Math.floor((new Date() - lastUpdateTime) / 1000);
            const uptimeText = uptime < 60 ? `${uptime}s` : `${Math.floor(uptime / 60)}m`;
            
            statsEl.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <span><strong>Live Stats:</strong></span>
                    <span style="color: ${isLiveUpdatesActive ? '#dc3545' : '#6c757d'};">
                        ${isLiveUpdatesActive ? 'üî¥ ACTIVE' : '‚ö´ PAUSED'}
                    </span>
                </div>
                <div style="margin-top: 5px; display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 10px; font-size: 10px;">
                    <span>Total: ${liveUpdateStats.totalUpdates}</span>
                    <span style="color: #dc3545;">Critical: ${liveUpdateStats.criticalAlerts}</span>
                    <span style="color: #ffc107;">Warning: ${liveUpdateStats.warningAlerts}</span>
                    <span style="color: #17a2b8;">Info: ${liveUpdateStats.infoAlerts}</span>
                </div>
                <div style="margin-top: 5px; font-size: 10px;">
                    Last update: ${uptimeText} ago | Next check: ${isLiveUpdatesActive ? 'within 30s' : 'paused'}
                </div>
            `;
        }

        // Generate real-time threat alerts
        function generateRealtimeThreatAlert() {
            const currentTime = new Date();
            const criticalThreats = [
                {
                    title: 'üö® APT Group Activity Detected',
                    messages: [
                        'Advanced persistent threat "Lazarus Group" infrastructure detected targeting financial sector',
                        'APT29 (Cozy Bear) command & control servers identified in network traffic',
                        'Suspected nation-state actor using zero-day exploit against Microsoft Exchange',
                        'APT40 group conducting reconnaissance against maritime industry targets',
                        'Chinese APT group "Stone Panda" deploying new custom malware variant'
                    ]
                },
                {
                    title: 'üö® Active Malware Campaign',
                    messages: [
                        'Emotet botnet resurgence detected with new C2 infrastructure',
                        'TrickBot malware evolution observed with enhanced anti-analysis features',
                        'Ryuk ransomware deployment detected following network compromise',
                        'BlackCat ransomware group targeting healthcare organizations',
                        'LockBit 3.0 ransomware campaign escalation in manufacturing sector'
                    ]
                },
                {
                    title: 'üö® Critical Vulnerability Exploitation',
                    messages: [
                        'Active exploitation of CVE-2023-44487 HTTP/2 vulnerability detected',
                        'Zero-day exploit targeting Adobe Acrobat Reader identified in wild',
                        'Microsoft Windows privilege escalation vulnerability being actively exploited',
                        'Citrix NetScaler security bypass attempts detected from multiple IPs',
                        'VMware vCenter Server authentication bypass under active attack'
                    ]
                }
            ];
            
            const warningThreats = [
                {
                    title: '‚ö†Ô∏è Suspicious Network Activity',
                    messages: [
                        'Unusual DNS queries to recently registered suspicious domains',
                        'Potential data exfiltration detected via encrypted channels',
                        'Anomalous login patterns suggesting credential stuffing attack',
                        'Suspicious PowerShell execution with obfuscated commands detected',
                        'Unusual network traffic patterns indicating potential C2 communication'
                    ]
                },
                {
                    title: '‚ö†Ô∏è Security Policy Violations',
                    messages: [
                        'Multiple failed authentication attempts exceeding policy threshold',
                        'Unauthorized software installation detected on critical systems',
                        'USB device policy violation: unknown device connected',
                        'Firewall rule modification detected outside maintenance window',
                        'Privileged account used outside normal business hours'
                    ]
                }
            ];
            
            const infoUpdates = [
                {
                    title: '‚ÑπÔ∏è Threat Intelligence Update',
                    messages: [
                        'IOC database updated with 2,847 new threat indicators',
                        'YARA rule repository synchronized with latest malware signatures',
                        'Threat feed integration completed: 15,230 new IOCs processed',
                        'Vulnerability database updated with 45 new CVE entries',
                        'Geolocation threat data refreshed for 89 countries'
                    ]
                },
                {
                    title: '‚ÑπÔ∏è System Performance Update',
                    messages: [
                        'Security monitoring coverage: 99.7% endpoint visibility maintained',
                        'Threat detection engine performance: 2.3ms average response time',
                        'Network traffic analysis: 847GB processed in last hour',
                        'Malware signature updates: 1,247 new patterns deployed',
                        'Security event correlation: 45,678 events processed successfully'
                    ]
                }
            ];
            
            // Determine alert type based on current time and randomness
            let alertType, alertData;
            const random = Math.random();
            
            if (random < 0.25) { // 25% critical
                alertType = 'critical';
                alertData = criticalThreats[Math.floor(Math.random() * criticalThreats.length)];
                liveUpdateStats.criticalAlerts++;
            } else if (random < 0.55) { // 30% warning
                alertType = 'warning';
                alertData = warningThreats[Math.floor(Math.random() * warningThreats.length)];
                liveUpdateStats.warningAlerts++;
            } else { // 45% info
                alertType = 'info';
                alertData = infoUpdates[Math.floor(Math.random() * infoUpdates.length)];
                liveUpdateStats.infoAlerts++;
            }
            
            const message = alertData.messages[Math.floor(Math.random() * alertData.messages.length)];
            
            const notification = {
                id: notificationId++,
                type: alertType,
                title: alertData.title,
                message: message,
                time: currentTime,
                read: false,
                isLive: true,
                source: 'Real-time Monitoring',
                actions: getActionsForType(alertType)
            };
            
            addLiveNotification(notification);
            
            // Show push notification for critical alerts
            if (alertType === 'critical') {
                showPushNotification(notification);
            }
            
            liveUpdateStats.totalUpdates++;
            console.log(`üî¥ Live ${alertType} alert generated: ${message.substring(0, 50)}...`);
        }

        // Generate threat intelligence updates
        function generateThreatIntelUpdate() {
            const intelUpdates = [
                {
                    title: '‚ÑπÔ∏è Threat Intelligence Feed Update',
                    messages: [
                        'MISP community feed synchronized: 3,456 new IOCs integrated',
                        'AlienVault OTX feed updated: 1,789 new threat indicators',
                        'VirusTotal intelligence report: 892 new malware samples analyzed',
                        'Emerging Threats ruleset updated: 234 new detection signatures',
                        'Recorded Future threat landscape report: 15 new threat actors profiled'
                    ]
                },
                {
                    title: '‚ÑπÔ∏è Global Threat Landscape',
                    messages: [
                        'Ransomware activity increased 23% in financial services sector',
                        'Phishing campaigns targeting cryptocurrency platforms surge detected',
                        'Supply chain attacks against software vendors increased globally',
                        'Mobile malware targeting banking applications rises in Asia-Pacific',
                        'State-sponsored groups increase focus on critical infrastructure'
                    ]
                }
            ];
            
            const updateData = intelUpdates[Math.floor(Math.random() * intelUpdates.length)];
            const message = updateData.messages[Math.floor(Math.random() * updateData.messages.length)];
            
            const notification = {
                id: notificationId++,
                type: 'info',
                title: updateData.title,
                message: message,
                time: new Date(),
                read: false,
                isLive: true,
                source: 'Threat Intelligence',
                actions: [{ label: 'View Details', action: 'details' }]
            };
            
            addLiveNotification(notification);
            liveUpdateStats.infoAlerts++;
            console.log('üîµ Threat intelligence update generated');
        }

        // Generate system status updates  
        function generateSystemStatusUpdate() {
            const statusUpdates = [
                {
                    title: '‚ÑπÔ∏è System Health Update',
                    messages: [
                        'Security infrastructure health check: All systems operational',
                        'Endpoint protection coverage: 99.8% of assets protected',
                        'Network monitoring capacity: Operating at 76% utilization',
                        'Threat detection pipeline: Processing 45,678 events per minute',
                        'Backup systems status: All redundant systems online and synchronized'
                    ]
                },
                {
                    title: '‚ÑπÔ∏è Performance Metrics',
                    messages: [
                        'Average threat detection latency: 1.2 seconds',
                        'False positive rate: Maintained below 2.1% threshold',
                        'Security analyst response time: Average 4.7 minutes',
                        'Incident escalation rate: 12% requiring immediate attention',
                        'Automation coverage: 87% of routine tasks fully automated'
                    ]
                }
            ];
            
            const updateData = statusUpdates[Math.floor(Math.random() * statusUpdates.length)];
            const message = updateData.messages[Math.floor(Math.random() * updateData.messages.length)];
            
            const notification = {
                id: notificationId++,
                type: 'info',
                title: updateData.title,
                message: message,
                time: new Date(),
                read: false,
                isLive: true,
                source: 'System Monitor',
                actions: [{ label: 'View Dashboard', action: 'details' }]
            };
            
            addLiveNotification(notification);
            liveUpdateStats.infoAlerts++;
            console.log('üü¢ System status update generated');
        }

        // Enhanced notification addition with live updates
        function addLiveNotification(notification) {
            notifications.unshift(notification);
            
            // Keep only last 100 notifications for performance
            if (notifications.length > 100) {
                notifications = notifications.slice(0, 100);
            }
            
            updateNotificationBadge();
            updateNotificationList();
            updateLiveIndicator();
            
            // Update last update time
            lastUpdateTime = new Date();
            
            console.log(`üì¢ Live notification added: ${notification.type} - ${notification.title}`);
        }

        // Update live status indicators
        function updateLiveStatus() {
            const now = new Date();
            const timeSinceUpdate = Math.floor((now - lastUpdateTime) / 1000);
            
            // Update live indicator in notification panel header
            updateNotificationPanelLiveStatus(timeSinceUpdate);
            
            // Update header live status
            updateHeaderLiveStatus();
        }

        function updateNotificationPanelLiveStatus(secondsSinceUpdate) {
            const header = document.querySelector('.notification-header h3');
            if (header) {
                const liveIndicator = isLiveUpdatesActive ? 
                    `üî¥ LIVE` : 
                    `‚ö´ OFFLINE`;
                    
                const updateInfo = secondsSinceUpdate < 60 ? 
                    `(${secondsSinceUpdate}s ago)` : 
                    `(${Math.floor(secondsSinceUpdate / 60)}m ago)`;
                    
                header.innerHTML = `üîî Security Alerts ${liveIndicator} ${isLiveUpdatesActive ? updateInfo : ''}`;
            }
        }

        function updateHeaderLiveStatus() {
            const headerStatus = document.getElementById('realtimeStatusHeader');
            if (headerStatus) {
                if (isLiveUpdatesActive) {
                    headerStatus.textContent = 'Real-time: Active (Notifications Live)';
                    headerStatus.className = 'realtime-status realtime-active';
                } else {
                    headerStatus.textContent = 'Real-time: Inactive (Notifications Paused)';
                    headerStatus.className = 'realtime-status realtime-inactive';
                }
            }
        }

        function updateLiveIndicator() {
            // Add live pulse animation to bell icon when new notification arrives
            const alertBell = document.getElementById('alertBell');
            if (alertBell && isLiveUpdatesActive) {
                alertBell.style.animation = 'pulse 0.5s ease-in-out';
                setTimeout(() => {
                    alertBell.style.animation = '';
                }, 500);
            }
        }

        // Refresh notification timestamps in real-time
        function refreshNotificationTimestamps() {
            const notificationItems = document.querySelectorAll('.notification-time');
            notificationItems.forEach((timeEl, index) => {
                if (notifications[index]) {
                    const timeAgo = getTimeAgo(notifications[index].time);
                    timeEl.textContent = timeAgo;
                }
            });
        }

        // Enhanced notification list with live indicators
        function updateNotificationList() {
            const notificationList = document.getElementById('notificationList');
            const noNotifications = document.getElementById('noNotifications');
            
            if (notifications.length === 0) {
                noNotifications.style.display = 'block';
                noNotifications.innerHTML = `
                    <div style="text-align: center; padding: 40px 20px; color: #999;">
                        ${isLiveUpdatesActive ? 
                            'üî¥ Live monitoring active<br>Waiting for security alerts...' : 
                            '‚ö´ Live updates paused<br>No active monitoring'}
                    </div>
                `;
                return;
            }
            
            noNotifications.style.display = 'none';
            
            notificationList.innerHTML = notifications.map(notification => {
                const timeAgo = getTimeAgo(notification.time);
                const iconSvg = getIconForType(notification.type);
                
                // Live indicator for real-time notifications
                const liveIndicator = notification.isLive ? 
                    '<span style="color: #dc3545; font-size: 10px;">‚óè LIVE</span>' : '';
                
                // Source indicator
                const sourceIndicator = notification.source ? 
                    `<span style="font-size: 10px; color: #666;">${notification.source}</span>` : '';
                
                const actionsHtml = notification.actions.map(action => 
                    `<button class="notification-action ${action.action === 'investigate' || action.action === 'details' ? 'primary' : ''}" 
                             onclick="performNotificationAction('${notification.id}', '${action.action}', event)">
                        ${action.label}
                    </button>`
                ).join('');
                
                return `
                    <div class="notification-item ${notification.read ? '' : 'unread'} ${notification.type}" 
                         onclick="markAsRead(${notification.id})">
                        <div class="notification-content">
                            <div class="notification-icon">${iconSvg}</div>
                            <div class="notification-body">
                                <div class="notification-title">
                                    ${notification.title} ${liveIndicator}
                                </div>
                                <div class="notification-message">${notification.message}</div>
                                <div class="notification-time">
                                    ${timeAgo} ${sourceIndicator}
                                </div>
                                <div class="notification-actions" onclick="event.stopPropagation()">
                                    ${actionsHtml}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Ensure notification system has absolute priority over ALL elements
        function ensureAbsolutePriority() {
            const container = document.getElementById('notificationContainer');
            const panel = document.getElementById('notificationPanel');
            const backdrop = document.getElementById('notificationBackdrop');
            const alertSystem = document.querySelector('.alert-system');
            
            if (container) {
                container.style.position = 'fixed';
                container.style.top = '0';
                container.style.left = '0';
                container.style.width = '100%';
                container.style.height = '100%';
                container.style.zIndex = '2147483647';
                container.style.pointerEvents = 'none';
            }
            
            if (panel) {
                panel.style.zIndex = '2147483647';
                panel.style.position = 'fixed';
            }
            
            if (backdrop) {
                backdrop.style.zIndex = '2147483646';
                backdrop.style.position = 'fixed';
            }
            
            if (alertSystem) {
                alertSystem.style.zIndex = '2147483645';
                alertSystem.style.position = 'absolute';
            }
            
            // Override any conflicting z-index from other elements
            const allElements = document.querySelectorAll('*:not(.notification-container):not(.notification-panel):not(.notification-backdrop):not(.alert-system):not(.push-notification)');
            allElements.forEach(el => {
                const currentZIndex = window.getComputedStyle(el).zIndex;
                if (currentZIndex !== 'auto' && parseInt(currentZIndex) >= 2147483640) {
                    el.style.zIndex = '1000'; // Reset high z-index elements
                }
            });
            
            console.log('Notification system priority ensured above all body elements');
        }

        function generateRandomAlert() {
            const alertTypes = [
                {
                    type: 'critical',
                    title: 'üö® Critical Threat Detected',
                    messages: [
                        'Advanced persistent threat detected from suspicious IP 192.168.1.100',
                        'Malware signature match: Trojan.Win32.Agent detected in network traffic',
                        'Brute force attack detected against SSH services',
                        'SQL injection attempt blocked on web application',
                        'Ransomware behavior detected on endpoint DESKTOP-WIN10'
                    ]
                },
                {
                    type: 'warning',
                    title: '‚ö†Ô∏è Security Warning',
                    messages: [
                        'Unusual network activity detected from internal host',
                        'Failed login attempts exceeded threshold for user account',
                        'Suspicious file upload detected in web application',
                        'Anomalous DNS queries to suspicious domains',
                        'Potential data exfiltration detected'
                    ]
                },
                {
                    type: 'info',
                    title: '‚ÑπÔ∏è Security Info',
                    messages: [
                        'Threat intelligence feed updated with 1,247 new IOCs',
                        'Security scan completed for 156 endpoints',
                        'Vulnerability database updated with 23 new CVEs',
                        'Firewall rules updated successfully',
                        'System backup completed successfully'
                    ]
                }
            ];

            const randomType = alertTypes[Math.floor(Math.random() * alertTypes.length)];
            const randomMessage = randomType.messages[Math.floor(Math.random() * randomType.messages.length)];
            
            const notification = {
                id: notificationId++,
                type: randomType.type,
                title: randomType.title,
                message: randomMessage,
                time: new Date(),
                read: false,
                actions: getActionsForType(randomType.type)
            };

            addNotification(notification);
            
            // Show push notification for critical alerts
            if (randomType.type === 'critical') {
                showPushNotification(notification);
            }
        }

        function getActionsForType(type) {
            switch(type) {
                case 'critical':
                    return [
                        { label: 'Investigate', action: 'investigate' },
                        { label: 'Block IP', action: 'block' }
                    ];
                case 'warning':
                    return [
                        { label: 'Review', action: 'review' },
                        { label: 'Ignore', action: 'ignore' }
                    ];
                case 'info':
                    return [
                        { label: 'View Details', action: 'details' }
                    ];
                default:
                    return [];
            }
        }

        function addNotification(notification) {
            notifications.unshift(notification);
            
            // Keep only last 50 notifications
            if (notifications.length > 50) {
                notifications = notifications.slice(0, 50);
            }
            
            updateNotificationBadge();
            updateNotificationList();
            
            console.log(`New ${notification.type} alert: ${notification.message}`);
        }

        function updateNotificationBadge() {
            const unreadCount = notifications.filter(n => !n.read).length;
            const badge = document.getElementById('alertBadge');
            
            if (unreadCount > 0) {
                badge.textContent = unreadCount > 99 ? '99+' : unreadCount;
                badge.style.display = 'flex';
            } else {
                badge.style.display = 'none';
            }
        }

        function updateNotificationList() {
            const notificationList = document.getElementById('notificationList');
            const noNotifications = document.getElementById('noNotifications');
            
            if (notifications.length === 0) {
                noNotifications.style.display = 'block';
                return;
            }
            
            noNotifications.style.display = 'none';
            
            notificationList.innerHTML = notifications.map(notification => {
                const timeAgo = getTimeAgo(notification.time);
                const iconSvg = getIconForType(notification.type);
                
                const actionsHtml = notification.actions.map(action => 
                    `<button class="notification-action ${action.action === 'investigate' || action.action === 'details' ? 'primary' : ''}" 
                             onclick="performNotificationAction('${notification.id}', '${action.action}', event)">
                        ${action.label}
                    </button>`
                ).join('');
                
                return `
                    <div class="notification-item ${notification.read ? '' : 'unread'} ${notification.type}" 
                         onclick="markAsRead(${notification.id})">
                        <div class="notification-content">
                            <div class="notification-icon">${iconSvg}</div>
                            <div class="notification-body">
                                <div class="notification-title">${notification.title}</div>
                                <div class="notification-message">${notification.message}</div>
                                <div class="notification-time">${timeAgo}</div>
                                <div class="notification-actions" onclick="event.stopPropagation()">
                                    ${actionsHtml}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function getIconForType(type) {
            const icons = {
                critical: '<svg viewBox="0 0 24 24" fill="#dc3545"><path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"/></svg>',
                warning: '<svg viewBox="0 0 24 24" fill="#ffc107"><path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"/></svg>',
                info: '<svg viewBox="0 0 24 24" fill="#17a2b8"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"/></svg>'
            };
            return icons[type] || icons.info;
        }

        function getTimeAgo(date) {
            const now = new Date();
            const diff = now - date;
            const seconds = Math.floor(diff / 1000);
            
            if (seconds < 60) return `${seconds}s ago`;
            
            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) return `${minutes}m ago`;
            
            const hours = Math.floor(minutes / 60);
            if (hours < 24) return `${hours}h ago`;
            
            const days = Math.floor(hours / 24);
            return `${days}d ago`;
        }

        function toggleNotificationPanel() {
            const panel = document.getElementById('notificationPanel');
            const backdrop = document.getElementById('notificationBackdrop');
            const container = document.getElementById('notificationContainer');
            isNotificationPanelOpen = !isNotificationPanelOpen;
            
            if (isNotificationPanelOpen) {
                // Ensure absolute priority above ALL body elements
                container.style.position = 'fixed';
                container.style.top = '0';
                container.style.left = '0';
                container.style.width = '100%';
                container.style.height = '100%';
                container.style.zIndex = '2147483647'; // Maximum z-index
                container.style.pointerEvents = 'none';
                
                panel.style.position = 'fixed';
                panel.style.top = '80px';
                panel.style.right = '20px';
                panel.style.zIndex = '2147483647';
                panel.style.pointerEvents = 'auto';
                
                backdrop.style.position = 'fixed';
                backdrop.style.top = '0';
                backdrop.style.left = '0';
                backdrop.style.width = '100%';
                backdrop.style.height = '100%';
                backdrop.style.zIndex = '2147483646';
                backdrop.style.pointerEvents = 'auto';
                
                panel.classList.add('show');
                backdrop.classList.add('show');
                
                console.log('Notification panel opened with absolute priority');
            } else {
                panel.classList.remove('show');
                backdrop.classList.remove('show');
            }
        }

        function closeNotificationPanel() {
            const panel = document.getElementById('notificationPanel');
            const backdrop = document.getElementById('notificationBackdrop');
            panel.classList.remove('show');
            backdrop.classList.remove('show');
            isNotificationPanelOpen = false;
        }

        function markAsRead(notificationId) {
            const notification = notifications.find(n => n.id == notificationId);
            if (notification) {
                notification.read = true;
                updateNotificationBadge();
                updateNotificationList();
            }
        }

        function markAllAsRead() {
            notifications.forEach(n => n.read = true);
            updateNotificationBadge();
            updateNotificationList();
        }

        function clearAllNotifications() {
            notifications = [];
            updateNotificationBadge();
            updateNotificationList();
        }

        function performNotificationAction(notificationId, action, event) {
            event.stopPropagation();
            
            const notification = notifications.find(n => n.id == notificationId);
            if (!notification) return;
            
            console.log(`Performing action '${action}' for notification: ${notification.message}`);
            
            switch(action) {
                case 'investigate':
                    showPushNotification({
                        type: 'info',
                        title: 'üîç Investigation Started',
                        message: 'Security investigation initiated for the reported threat.'
                    });
                    break;
                case 'block':
                    showPushNotification({
                        type: 'info',
                        title: 'üö´ IP Blocked',
                        message: 'Malicious IP address has been added to the blocklist.'
                    });
                    break;
                case 'review':
                    showPushNotification({
                        type: 'info',
                        title: 'üìã Under Review',
                        message: 'Alert marked for security team review.'
                    });
                    break;
                case 'ignore':
                    // Remove notification
                    notifications = notifications.filter(n => n.id != notificationId);
                    updateNotificationBadge();
                    updateNotificationList();
                    break;
                case 'details':
                    showPushNotification({
                        type: 'info',
                        title: 'üìä Details Panel',
                        message: 'Detailed analysis view would open here.'
                    });
                    break;
            }
            
            // Mark as read
            markAsRead(notificationId);
        }

        // Push Notification System
        function showPushNotification(notification) {
            // Browser notification
            if ('Notification' in window && Notification.permission === 'granted') {
                new Notification(notification.title, {
                    body: notification.message,
                    icon: '/favicon.ico',
                    badge: '/favicon.ico'
                });
            }
            
            // Custom push notification
            const pushContainer = createPushNotificationElement(notification);
            document.body.appendChild(pushContainer);
            
            // Show with animation
            setTimeout(() => {
                pushContainer.classList.add('show');
            }, 100);
            
            // Auto-hide after 5 seconds
            setTimeout(() => {
                hidePushNotification(pushContainer);
            }, 5000);
        }

        function createPushNotificationElement(notification) {
            const pushDiv = document.createElement('div');
            pushDiv.className = `push-notification ${notification.type}`;
            
            const iconSvg = getIconForType(notification.type);
            
            pushDiv.innerHTML = `
                <div class="push-content">
                    <div class="push-icon">${iconSvg}</div>
                    <div class="push-body">
                        <div class="push-title">${notification.title}</div>
                        <div class="push-message">${notification.message}</div>
                    </div>
                    <button class="push-close" onclick="hidePushNotification(this.closest('.push-notification'))">√ó</button>
                </div>
            `;
            
            return pushDiv;
        }

        function hidePushNotification(element) {
            element.classList.remove('show');
            setTimeout(() => {
                if (element.parentNode) {
                    element.parentNode.removeChild(element);
                }
            }, 400);
        }

        // Manual Alert Functions for Testing
        function triggerCriticalAlert() {
            const notification = {
                id: notificationId++,
                type: 'critical',
                title: 'üö® Manual Critical Alert',
                message: 'This is a manually triggered critical security alert for testing purposes.',
                time: new Date(),
                read: false,
                actions: [
                    { label: 'Investigate', action: 'investigate' },
                    { label: 'Block IP', action: 'block' }
                ]
            };
            
            addNotification(notification);
            showPushNotification(notification);
        }

        function triggerWarningAlert() {
            const notification = {
                id: notificationId++,
                type: 'warning',
                title: '‚ö†Ô∏è Manual Warning Alert',
                message: 'This is a manually triggered warning alert for testing purposes.',
                time: new Date(),
                read: false,
                actions: [
                    { label: 'Review', action: 'review' },
                    { label: 'Ignore', action: 'ignore' }
                ]
            };
            
            addNotification(notification);
        }

        function triggerInfoAlert() {
            const notification = {
                id: notificationId++,
                type: 'info',
                title: '‚ÑπÔ∏è Manual Info Alert',
                message: 'This is a manually triggered informational alert for testing purposes.',
                time: new Date(),
                read: false,
                actions: [
                    { label: 'View Details', action: 'details' }
                ]
            };
            
            addNotification(notification);
        }

        function submitThreat() {
            // This would integrate with the existing threat submission system
            const threatText = document.getElementById('threatText').value;
            if (!threatText.trim()) {
                alert('Please enter a threat description');
                return;
            }
            
            // For now, just analyze the text as a threat
            document.getElementById('analyzeText').value = threatText;
            showAnalyzer();
            analyzeText();
            
            document.getElementById('threatText').value = '';
        }

        function startAutoRefresh() {
            refreshInterval = setInterval(() => {
                loadDashboardStats();
                loadRecentThreats();
                updateRealtimeStats();
            }, 30000); // Refresh every 30 seconds
        }

        function stopAutoRefresh() {
            if (refreshInterval) {
                clearInterval(refreshInterval);
            }
        }

        // Threat Intelligence Sharing Functions
        function showIntelligenceStatus(message, progress = 0) {
            const statusDiv = document.getElementById('intelligenceStatus');
            const messageDiv = document.getElementById('intelligenceMessage');
            const progressBar = document.getElementById('intelligenceProgress');
            
            messageDiv.textContent = message;
            progressBar.style.width = progress + '%';
            statusDiv.style.display = 'block';
            
            if (progress >= 100) {
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 3000);
            }
        }

        function uploadIntelligence() {
            const fileInput = document.getElementById('fileUpload');
            const uploadBtn = document.getElementById('uploadBtn');
            
            if (!fileInput.files.length) {
                alert('Please select a file to upload');
                return;
            }
            
            const formData = new FormData();
            formData.append('file', fileInput.files[0]);
            
            uploadBtn.disabled = true;
            uploadBtn.textContent = 'Uploading...';
            showIntelligenceStatus('Uploading file...', 25);
            
            fetch('/api/dashboard/intelligence/upload', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                showIntelligenceStatus('Upload completed!', 100);
                
                if (data.status === 'success') {
                    alert(`Upload successful! Processed ${data.threats_processed} threats.`);
                    loadRecentThreats();
                    loadDashboardStats();
                } else {
                    alert('Upload failed: ' + (data.message || 'Unknown error'));
                }
            })
            .catch(error => {
                console.error('Upload error:', error);
                showIntelligenceStatus('Upload failed!', 100);
                alert('Upload failed due to network error');
            })
            .finally(() => {
                uploadBtn.disabled = false;
                uploadBtn.textContent = 'Upload File';
                fileInput.value = '';
            });
        }

        function showImportDialog() {
            const importDialog = document.getElementById('importDialog');
            importDialog.style.display = importDialog.style.display === 'none' ? 'block' : 'none';
        }

        function hideImportDialog() {
            document.getElementById('importDialog').style.display = 'none';
            document.getElementById('importData').value = '';
            document.getElementById('importResult').style.display = 'none';
        }

        function importIntelligence() {
            const source = document.getElementById('importSourceSelect').value;
            const dataText = document.getElementById('importData').value.trim();
            const submitBtn = document.getElementById('importSubmitBtn');
            const resultDiv = document.getElementById('importResult');
            
            if (!dataText) {
                alert('Please enter data to import');
                return;
            }
            
            let importData;
            try {
                if (source !== 'manual') {
                    importData = JSON.parse(dataText);
                } else {
                    // Manual entry - each line is a threat
                    const lines = dataText.split('\n').filter(line => line.trim());
                    importData = {
                        threats: lines.map(line => ({
                            description: line.trim(),
                            category: 'manual',
                            severity: 'MEDIUM'
                        }))
                    };
                }
            } catch (e) {
                alert('Invalid data format. Please check your input.');
                return;
            }
            
            submitBtn.disabled = true;
            submitBtn.textContent = 'Importing...';
            showIntelligenceStatus('Importing threat intelligence...', 50);
            
            fetch('/api/dashboard/intelligence/import', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({source: source, ...importData})
            })
            .then(response => response.json())
            .then(data => {
                showIntelligenceStatus('Import completed!', 100);
                
                if (data.status === 'success') {
                    resultDiv.innerHTML = `
                        <h3>‚úÖ Import Successful</h3>
                        <p>Imported ${data.threats_imported} threats from ${data.source}</p>
                        <p>Timestamp: ${data.timestamp}</p>
                    `;
                    resultDiv.style.display = 'block';
                    loadRecentThreats();
                    loadDashboardStats();
                } else {
                    resultDiv.innerHTML = `<p style="color: #dc3545;">Import failed: ${data.message}</p>`;
                    resultDiv.style.display = 'block';
                }
            })
            .catch(error => {
                console.error('Import error:', error);
                showIntelligenceStatus('Import failed!', 100);
                resultDiv.innerHTML = '<p style="color: #dc3545;">Import failed due to network error</p>';
                resultDiv.style.display = 'block';
            })
            .finally(() => {
                submitBtn.disabled = false;
                submitBtn.textContent = 'Import Data';
            });
        }

        function exportIntelligence() {
            const format = document.getElementById('exportFormat').value;
            const exportBtn = document.getElementById('exportBtn');
            
            exportBtn.disabled = true;
            exportBtn.textContent = 'Exporting...';
            showIntelligenceStatus('Exporting threat intelligence...', 75);
            
            // Create download link
            const url = `/api/dashboard/intelligence/export?format=${format}`;
            const link = document.createElement('a');
            link.href = url;
            link.download = `threat_intelligence.${format}`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            showIntelligenceStatus('Export completed!', 100);
            exportBtn.disabled = false;
            exportBtn.textContent = 'Export Data';
        }

        function extractEntities() {
            const text = document.getElementById('analyzeText').value;
            const entitiesBtn = document.getElementById('entitiesBtn');
            const resultDiv = document.getElementById('entitiesResult');
            
            if (!text.trim()) {
                alert('Please enter text to extract entities from');
                return;
            }
            
            entitiesBtn.disabled = true;
            entitiesBtn.textContent = 'Extracting...';
            
            fetch('/api/dashboard/semantic/entities', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({text: text})
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    const entities = data.entities;
                    const stats = data.statistics;
                    
                    let entitiesHtml = '<h3>üîç Extracted Entities</h3>';
                    entitiesHtml += `<p><strong>Total entities found:</strong> ${stats.total_entities}</p>`;
                    
                    for (const [type, values] of Object.entries(entities)) {
                        if (values.length > 0) {
                            entitiesHtml += `<p><strong>${type.replace('_', ' ').toUpperCase()}:</strong> ${values.join(', ')}</p>`;
                        }
                    }
                    
                    resultDiv.innerHTML = entitiesHtml;
                    resultDiv.style.display = 'block';
                } else {
                    resultDiv.innerHTML = `<p style="color: #dc3545;">Entity extraction failed: ${data.message}</p>`;
                    resultDiv.style.display = 'block';
                }
            })
            .catch(error => {
                console.error('Entity extraction error:', error);
                resultDiv.innerHTML = '<p style="color: #dc3545;">Entity extraction failed due to network error</p>';
                resultDiv.style.display = 'block';
            })
            .finally(() => {
                entitiesBtn.disabled = false;
                entitiesBtn.textContent = 'Extract Entities';
            });
        }

        function analyzeBulk() {
            const bulkText = document.getElementById('bulkAnalyzeText').value;
            const bulkBtn = document.getElementById('bulkAnalyzeBtn');
            const resultDiv = document.getElementById('bulkAnalysisResult');
            
            if (!bulkText.trim()) {
                alert('Please enter texts to analyze (one per line)');
                return;
            }
            
            const texts = bulkText.split('\n').filter(line => line.trim()).map(line => line.trim());
            
            bulkBtn.disabled = true;
            bulkBtn.textContent = 'Analyzing...';
            showIntelligenceStatus('Performing bulk analysis...', 60);
            
            fetch('/api/dashboard/semantic/analyze-bulk', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({texts: texts})
            })
            .then(response => response.json())
            .then(data => {
                showIntelligenceStatus('Bulk analysis completed!', 100);
                
                if (data.status === 'success') {
                    let analysisHtml = '<h3>üìä Bulk Analysis Results</h3>';
                    analysisHtml += `<div style="margin-bottom: 15px;">`;
                    analysisHtml += `<strong>Total analyzed:</strong> ${data.total_analyzed}<br>`;
                    analysisHtml += `<strong>Successful analyses:</strong> ${data.successful_analyses}<br>`;
                    analysisHtml += `<strong>Threats detected:</strong> ${data.threats_detected}<br>`;
                    analysisHtml += `</div>`;
                    
                    analysisHtml += '<h4>Category Distribution:</h4>';
                    for (const [category, count] of Object.entries(data.categories_distribution)) {
                        analysisHtml += `<div>${category}: ${count}</div>`;
                    }
                    
                    analysisHtml += '<h4>Severity Distribution:</h4>';
                    for (const [severity, count] of Object.entries(data.severities_distribution)) {
                        analysisHtml += `<div>${severity}: ${count}</div>`;
                    }
                    
                    resultDiv.innerHTML = analysisHtml;
                    resultDiv.style.display = 'block';
                    
                    loadRecentThreats(); // Refresh to show new analyzed threats
                    loadDashboardStats();
                } else {
                    resultDiv.innerHTML = `<p style="color: #dc3545;">Bulk analysis failed: ${data.message}</p>`;
                    resultDiv.style.display = 'block';
                }
            })
            .catch(error => {
                console.error('Bulk analysis error:', error);
                showIntelligenceStatus('Bulk analysis failed!', 100);
                resultDiv.innerHTML = '<p style="color: #dc3545;">Bulk analysis failed due to network error</p>';
                resultDiv.style.display = 'block';
            })
            .finally(() => {
                bulkBtn.disabled = false;
                bulkBtn.textContent = 'Analyze All Texts';
            });
        }

        // Initialize dashboard
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize original dashboard components
            loadDashboardStats();
            loadRecentThreats();
            loadCategories();
            updateRealtimeStats();
            startAutoRefresh();
            
            // Initialize all active charts
            initializeSeverityChart();
            initializeAttackVectorsChart();
            initializeGeographicChart();
            initializeHourlyActivityChart();
            initializeSystemHealthChart();
            initializeResourceDistributionChart();
            initializeFeedStatusChart();
            initializeIOCTypesChart();
            
            // Initialize advanced features
            createAdvancedTooltips();
            
            // Initialize live updates for threat feeds table
            updateFeedSourcesTable();
            
            // Initialize Alert System with absolute priority and live updates
            initializeAlertSystem();
            
            // Initialize Live Charts Information System
            setTimeout(() => {
                startLiveChartsInformation();
            }, 3000);
            
            // Initialize live stats display
            setTimeout(() => {
                updateLiveStatsDisplay();
            }, 2000);
            
            // Periodic check to maintain absolute priority (every 5 seconds)
            setInterval(ensureAbsolutePriority, 5000);
            
            console.log('Complete Active Dashboard with Live Charts and Notification Updates initialized successfully');
            
            // Initialize Active Incidents and Blocked Attacks
            loadActiveIncidents();
            loadBlockedAttacks();
        });

        // ================================
        // ACTIVE INCIDENTS MANAGEMENT
        // ================================

        let incidentsInterval = null;
        let blockedAttacksInterval = null;

        function loadActiveIncidents() {
            const incidentsList = document.getElementById('activeIncidentsList');
            const incidentsCount = document.getElementById('activeIncidentsCount');
            
            // Generate sample active incidents
            const sampleIncidents = generateSampleIncidents();
            
            incidentsList.innerHTML = '';
            sampleIncidents.forEach((incident, index) => {
                const incidentElement = createIncidentElement(incident, index);
                incidentsList.appendChild(incidentElement);
            });
            
            incidentsCount.textContent = sampleIncidents.length;
        }

        function generateSampleIncidents() {
            const incidentTypes = [
                { type: 'Malware Detection', severity: 'Critical', icon: 'ü¶†' },
                { type: 'Phishing Attempt', severity: 'High', icon: 'üé£' },
                { type: 'Brute Force Attack', severity: 'Medium', icon: 'üî®' },
                { type: 'SQL Injection', severity: 'High', icon: 'üíâ' },
                { type: 'DDoS Attack', severity: 'Critical', icon: 'üå™Ô∏è' },
                { type: 'Privilege Escalation', severity: 'High', icon: '‚¨ÜÔ∏è' },
                { type: 'Data Exfiltration', severity: 'Critical', icon: 'üì§' },
                { type: 'Ransomware Activity', severity: 'Critical', icon: 'üîí' }
            ];
            
            const sources = ['192.168.1.100', '10.0.0.45', '203.45.67.89', '172.16.0.25', '8.8.8.8'];
            const targets = ['Web Server', 'Database', 'Domain Controller', 'File Server', 'Email Server'];
            
            const incidents = [];
            const numIncidents = Math.floor(Math.random() * 8) + 3; // 3-10 incidents
            
            for (let i = 0; i < numIncidents; i++) {
                const incident = incidentTypes[Math.floor(Math.random() * incidentTypes.length)];
                const minutesAgo = Math.floor(Math.random() * 120) + 1; // 1-120 minutes ago
                
                incidents.push({
                    id: `INC-${Date.now()}-${i}`,
                    type: incident.type,
                    severity: incident.severity,
                    icon: incident.icon,
                    source: sources[Math.floor(Math.random() * sources.length)],
                    target: targets[Math.floor(Math.random() * targets.length)],
                    timeAgo: `${minutesAgo}m ago`,
                    status: Math.random() > 0.3 ? 'Investigating' : 'Confirmed'
                });
            }
            
            return incidents.sort((a, b) => {
                const severityOrder = { 'Critical': 3, 'High': 2, 'Medium': 1, 'Low': 0 };
                return severityOrder[b.severity] - severityOrder[a.severity];
            });
        }

        function createIncidentElement(incident, index) {
            const div = document.createElement('div');
            const severityColor = {
                'Critical': '#dc3545',
                'High': '#fd7e14',
                'Medium': '#ffc107',
                'Low': '#28a745'
            }[incident.severity];
            
            div.style.cssText = `
                background: linear-gradient(135deg, ${severityColor}15 0%, ${severityColor}05 100%);
                border-left: 4px solid ${severityColor};
                border-radius: 8px;
                padding: 12px;
                margin-bottom: 8px;
                cursor: pointer;
                transition: all 0.3s ease;
                animation: slideInLeft 0.5s ease ${index * 0.1}s both;
            `;
            
            div.innerHTML = `
                <div style="display: flex; align-items: center; gap: 10px;">
                    <span style="font-size: 20px;">${incident.icon}</span>
                    <div style="flex: 1;">
                        <div style="font-weight: bold; font-size: 14px; color: #333;">
                            ${incident.type}
                        </div>
                        <div style="font-size: 12px; color: #666; margin-top: 2px;">
                            ${incident.source} ‚Üí ${incident.target}
                        </div>
                        <div style="font-size: 11px; color: #888; margin-top: 4px;">
                            ID: ${incident.id} ‚Ä¢ ${incident.timeAgo}
                        </div>
                    </div>
                    <div style="text-align: right;">
                        <span style="background: ${severityColor}; color: white; padding: 4px 8px; border-radius: 12px; font-size: 10px; font-weight: bold;">
                            ${incident.severity}
                        </span>
                        <div style="font-size: 11px; color: #666; margin-top: 4px;">
                            ${incident.status}
                        </div>
                    </div>
                </div>
            `;
            
            div.addEventListener('mouseenter', () => {
                div.style.transform = 'translateX(5px)';
                div.style.boxShadow = '0 4px 15px rgba(0,0,0,0.1)';
            });
            
            div.addEventListener('mouseleave', () => {
                div.style.transform = 'translateX(0)';
                div.style.boxShadow = 'none';
            });
            
            return div;
        }

        function loadBlockedAttacks() {
            const attacksList = document.getElementById('blockedAttacksList');
            const attacksCount = document.getElementById('blockedAttacksCount');
            
            // Generate sample blocked attacks
            const sampleAttacks = generateSampleBlockedAttacks();
            
            attacksList.innerHTML = '';
            sampleAttacks.forEach((attack, index) => {
                const attackElement = createBlockedAttackElement(attack, index);
                attacksList.appendChild(attackElement);
            });
            
            attacksCount.textContent = sampleAttacks.length;
        }

        function generateSampleBlockedAttacks() {
            const attackTypes = [
                { type: 'Port Scan', action: 'Firewall Block', icon: 'üîç' },
                { type: 'Malicious Download', action: 'Web Filter', icon: '‚¨áÔ∏è' },
                { type: 'C&C Communication', action: 'DNS Block', icon: 'üì°' },
                { type: 'Exploit Attempt', action: 'IPS Block', icon: 'üí•' },
                { type: 'Suspicious Login', action: 'Auth Block', icon: 'üö™' },
                { type: 'File Upload', action: 'Content Filter', icon: 'üìÅ' },
                { type: 'Data Transfer', action: 'DLP Block', icon: 'üö´' },
                { type: 'Script Execution', action: 'Endpoint Block', icon: 'üìú' }
            ];
            
            const countries = ['China', 'Russia', 'North Korea', 'Iran', 'Unknown', 'Brazil', 'India'];
            const protocols = ['TCP', 'UDP', 'HTTP', 'HTTPS', 'SSH', 'FTP', 'DNS'];
            
            const attacks = [];
            const numAttacks = Math.floor(Math.random() * 15) + 10; // 10-24 attacks
            
            for (let i = 0; i < numAttacks; i++) {
                const attack = attackTypes[Math.floor(Math.random() * attackTypes.length)];
                const secondsAgo = Math.floor(Math.random() * 3600) + 1; // 1 second to 1 hour ago
                const timeAgo = secondsAgo < 60 ? `${secondsAgo}s ago` : 
                               secondsAgo < 3600 ? `${Math.floor(secondsAgo/60)}m ago` : 
                               `${Math.floor(secondsAgo/3600)}h ago`;
                
                attacks.push({
                    id: `BLK-${Date.now()}-${i}`,
                    type: attack.type,
                    action: attack.action,
                    icon: attack.icon,
                    sourceIP: `${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}`,
                    country: countries[Math.floor(Math.random() * countries.length)],
                    protocol: protocols[Math.floor(Math.random() * protocols.length)],
                    timeAgo: timeAgo,
                    severity: Math.random() > 0.5 ? 'High' : 'Medium'
                });
            }
            
            return attacks.sort((a, b) => {
                const timeA = parseInt(a.timeAgo);
                const timeB = parseInt(b.timeAgo);
                return timeA - timeB; // Most recent first
            });
        }

        function createBlockedAttackElement(attack, index) {
            const div = document.createElement('div');
            const actionColor = {
                'Firewall Block': '#17a2b8',
                'Web Filter': '#6f42c1',
                'DNS Block': '#e83e8c',
                'IPS Block': '#fd7e14',
                'Auth Block': '#dc3545',
                'Content Filter': '#28a745',
                'DLP Block': '#ffc107',
                'Endpoint Block': '#6c757d'
            }[attack.action] || '#6c757d';
            
            div.style.cssText = `
                background: linear-gradient(135deg, ${actionColor}10 0%, ${actionColor}05 100%);
                border-left: 3px solid ${actionColor};
                border-radius: 6px;
                padding: 10px;
                margin-bottom: 6px;
                cursor: pointer;
                transition: all 0.3s ease;
                animation: slideInRight 0.4s ease ${index * 0.05}s both;
            `;
            
            div.innerHTML = `
                <div style="display: flex; align-items: center; gap: 8px;">
                    <span style="font-size: 16px;">${attack.icon}</span>
                    <div style="flex: 1;">
                        <div style="font-weight: bold; font-size: 13px; color: #333;">
                            ${attack.type}
                        </div>
                        <div style="font-size: 11px; color: #666; margin-top: 1px;">
                            ${attack.sourceIP} (${attack.country}) ‚Ä¢ ${attack.protocol}
                        </div>
                    </div>
                    <div style="text-align: right;">
                        <span style="background: ${actionColor}; color: white; padding: 2px 6px; border-radius: 10px; font-size: 9px; font-weight: bold;">
                            ${attack.action}
                        </span>
                        <div style="font-size: 10px; color: #888; margin-top: 2px;">
                            ${attack.timeAgo}
                        </div>
                    </div>
                </div>
            `;
            
            div.addEventListener('mouseenter', () => {
                div.style.transform = 'translateX(-3px)';
                div.style.boxShadow = '0 2px 10px rgba(0,0,0,0.1)';
            });
            
            div.addEventListener('mouseleave', () => {
                div.style.transform = 'translateX(0)';
                div.style.boxShadow = 'none';
            });
            
            return div;
        }

        function toggleIncidentsLiveMode() {
            const btn = document.getElementById('incidentsLiveBtn');
            
            if (!incidentsInterval) {
                incidentsInterval = setInterval(() => {
                    loadActiveIncidents();
                }, 8000); // Update every 8 seconds
                
                btn.textContent = 'üî¥ Stop Live Mode';
                btn.style.background = 'linear-gradient(135deg, #dc3545 0%, #e83e8c 100%)';
                console.log('Active Incidents live mode started');
            } else {
                clearInterval(incidentsInterval);
                incidentsInterval = null;
                btn.textContent = 'üî¥ Start Live Mode';
                btn.style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';
                console.log('Active Incidents live mode stopped');
            }
        }

        function toggleBlockedAttacksLiveMode() {
            const btn = document.getElementById('blockedAttacksLiveBtn');
            
            if (!blockedAttacksInterval) {
                blockedAttacksInterval = setInterval(() => {
                    loadBlockedAttacks();
                }, 5000); // Update every 5 seconds
                
                btn.textContent = 'üî¥ Stop Live Mode';
                btn.style.background = 'linear-gradient(135deg, #dc3545 0%, #e83e8c 100%)';
                console.log('Blocked Attacks live mode started');
            } else {
                clearInterval(blockedAttacksInterval);
                blockedAttacksInterval = null;
                btn.textContent = 'üî¥ Start Live Mode';
                btn.style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';
                console.log('Blocked Attacks live mode stopped');
            }
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', stopAutoRefresh);
    </script>

    <!-- NOTIFICATION SYSTEM CONTAINER - ABSOLUTE PRIORITY ABOVE ALL BODY ELEMENTS -->
    <div class="notification-container" id="notificationContainer">
        <!-- Notification Backdrop -->
        <div class="notification-backdrop" id="notificationBackdrop" onclick="closeNotificationPanel()"></div>
        
        <!-- Notification Panel -->
        <div class="notification-panel" id="notificationPanel">
            <div class="notification-header">
                <h3>üîî Security Alerts üî¥ LIVE</h3>
                <div class="panel-controls">
                    <button class="control-btn" id="liveToggleBtn" onclick="toggleLiveUpdates()">
                        üì° Live
                    </button>
                    <button class="control-btn" onclick="markAllAsRead()">Mark All Read</button>
                    <button class="control-btn" onclick="clearAllNotifications()">Clear All</button>
                    <button class="control-btn" onclick="toggleNotificationPanel()">√ó</button>
                </div>
            </div>
            <div class="notification-list" id="notificationList">
                <div class="no-notifications" id="noNotifications">
                    No active alerts
                </div>
            </div>
        </div>
    </div>
</body>
</html>